/// SyntaxNodes.swift
/// Automatically generated by SyntaxGen. Do not edit!
///
/// Copyright 2017-2018, The Silt Language Project.
///
/// This project is released under the MIT license, a copy of which is
/// available in the repository.
public protocol DeclSyntax: Syntax {}
public protocol ExprSyntax: Syntax {}
public protocol TypedParameterSyntax: Syntax {}
public protocol FunctionClauseDeclSyntax: DeclSyntax {}
public protocol FixityDeclSyntax: DeclSyntax {}
public protocol BindingSyntax: Syntax {}
public protocol BasicExprSyntax: ExprSyntax {}
public struct IdentifierListSyntax: _SyntaxBase {
  let _root: SyntaxData
  unowned let _data: SyntaxData

  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
  }

  public init(elements: [TokenSyntax]) {
    let list = elements.map { $0.raw }
    let sd = SyntaxData(raw: .node(.identifierList, list, .present))
    self._root = sd
    self._data = sd
  }


  /// Creates a new IdentifierListSyntax by replacing the underlying layout with
  /// a different set of raw syntax nodes.
  ///
  /// - Parameter layout: The new list of raw syntax nodes underlying this
  ///                     collection.
  /// - Returns: A new SyntaxCollection with the new layout underlying it.
  internal func replacingLayout(
    _ layout: [RawSyntax]) -> IdentifierListSyntax {
    let newRaw = data.raw.replacingLayout(layout)
    let (newRoot, newData) = data.replacingSelf(newRaw)
    return IdentifierListSyntax(root: newRoot, data: newData)
  }

  /// Creates a new IdentifierListSyntax by appending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to append.
  /// - Returns: A new SyntaxCollection with that element appended to the end.
  public func appending(
    _ syntax: TokenSyntax) -> IdentifierListSyntax {
    var newLayout = data.raw.layout
    newLayout.append(syntax.raw)
    return replacingLayout(newLayout)
  }

  /// Creates a new IdentifierListSyntax by prepending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to prepend.
  /// - Returns: A new SyntaxCollection with that element prepended to the
  ///            beginning.
  public func prepending(
    _ syntax: TokenSyntax) -> IdentifierListSyntax {
    return inserting(syntax, at: 0)
  }

  /// Creates a new IdentifierListSyntax by inserting the provided syntax element
  /// at the provided index in the children.
  ///
  /// - Parameters:
  ///   - syntax: The element to insert.
  ///   - index: The index at which to insert the element in the collection.
  ///
  /// - Returns: A new IdentifierListSyntax with that element appended to the end.
  public func inserting(_ syntax: TokenSyntax,
                        at index: Int) -> IdentifierListSyntax {
    var newLayout = data.raw.layout
    /// Make sure the index is a valid insertion index (0 to 1 past the end)
    precondition((newLayout.startIndex...newLayout.endIndex).contains(index),
                 "inserting node at invalid index \(index)")
    newLayout.insert(syntax.raw, at: index)
    return replacingLayout(newLayout)
  }

  /// Creates a new IdentifierListSyntax by removing the syntax element at the
  /// provided index.
  ///
  /// - Parameter index: The index of the element to remove from the collection.
  /// - Returns: A new IdentifierListSyntax with the element at the provided index
  ///            removed.
  public func removing(childAt index: Int) -> IdentifierListSyntax {
    var newLayout = data.raw.layout
    newLayout.remove(at: index)
    return replacingLayout(newLayout)
  }

  /// Creates a new IdentifierListSyntax by removing the first element.
  ///
  /// - Returns: A new IdentifierListSyntax with the first element removed.
  public func removingFirst() -> IdentifierListSyntax {
    var newLayout = data.raw.layout
    newLayout.removeFirst()
    return replacingLayout(newLayout)
  }

  /// Creates a new IdentifierListSyntax by removing the last element.
  ///
  /// - Returns: A new IdentifierListSyntax with the last element removed.
  public func removingLast() -> IdentifierListSyntax {
    var newLayout = data.raw.layout
    newLayout.removeLast()
    return replacingLayout(newLayout)
  }

  /// Returns an iterator over the elements of this syntax collection.
  public func makeIterator() -> IdentifierListSyntaxIterator {
    return IdentifierListSyntaxIterator(collection: self)
  }
}

/// Conformance for IdentifierListSyntax to the Collection protocol.
extension IdentifierListSyntax: Collection {
  public var startIndex: Int {
    return data.childCaches.startIndex
  }

  public var endIndex: Int {
    return data.childCaches.endIndex
  }

  public func index(after i: Int) -> Int {
    return data.childCaches.index(after: i)
  }

  public subscript(_ index: Int) -> TokenSyntax {
    // swiftlint:disable force_cast
    return child(at: index)! as! TokenSyntax
  }
}

/// A type that iterates over a syntax collection using its indices.
public struct IdentifierListSyntaxIterator: IteratorProtocol {
  private let collection: IdentifierListSyntax
  private var index: IdentifierListSyntax.Index

  fileprivate init(collection: IdentifierListSyntax) {
    self.collection = collection
    self.index = collection.startIndex
  }

  public mutating func next() -> TokenSyntax? {
    guard
      !(self.collection.isEmpty || self.index == self.collection.endIndex)
    else {
      return nil
    }

    let result = collection[index]
    collection.formIndex(after: &index)
    return result
  }
}
public struct QualifiedNameSyntax: _SyntaxBase {
  let _root: SyntaxData
  unowned let _data: SyntaxData

  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
  }

  public init(elements: [QualifiedNamePieceSyntax]) {
    let list = elements.map { $0.raw }
    let sd = SyntaxData(raw: .node(.qualifiedName, list, .present))
    self._root = sd
    self._data = sd
  }


  /// Creates a new QualifiedNameSyntax by replacing the underlying layout with
  /// a different set of raw syntax nodes.
  ///
  /// - Parameter layout: The new list of raw syntax nodes underlying this
  ///                     collection.
  /// - Returns: A new SyntaxCollection with the new layout underlying it.
  internal func replacingLayout(
    _ layout: [RawSyntax]) -> QualifiedNameSyntax {
    let newRaw = data.raw.replacingLayout(layout)
    let (newRoot, newData) = data.replacingSelf(newRaw)
    return QualifiedNameSyntax(root: newRoot, data: newData)
  }

  /// Creates a new QualifiedNameSyntax by appending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to append.
  /// - Returns: A new SyntaxCollection with that element appended to the end.
  public func appending(
    _ syntax: QualifiedNamePieceSyntax) -> QualifiedNameSyntax {
    var newLayout = data.raw.layout
    newLayout.append(syntax.raw)
    return replacingLayout(newLayout)
  }

  /// Creates a new QualifiedNameSyntax by prepending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to prepend.
  /// - Returns: A new SyntaxCollection with that element prepended to the
  ///            beginning.
  public func prepending(
    _ syntax: QualifiedNamePieceSyntax) -> QualifiedNameSyntax {
    return inserting(syntax, at: 0)
  }

  /// Creates a new QualifiedNameSyntax by inserting the provided syntax element
  /// at the provided index in the children.
  ///
  /// - Parameters:
  ///   - syntax: The element to insert.
  ///   - index: The index at which to insert the element in the collection.
  ///
  /// - Returns: A new QualifiedNameSyntax with that element appended to the end.
  public func inserting(_ syntax: QualifiedNamePieceSyntax,
                        at index: Int) -> QualifiedNameSyntax {
    var newLayout = data.raw.layout
    /// Make sure the index is a valid insertion index (0 to 1 past the end)
    precondition((newLayout.startIndex...newLayout.endIndex).contains(index),
                 "inserting node at invalid index \(index)")
    newLayout.insert(syntax.raw, at: index)
    return replacingLayout(newLayout)
  }

  /// Creates a new QualifiedNameSyntax by removing the syntax element at the
  /// provided index.
  ///
  /// - Parameter index: The index of the element to remove from the collection.
  /// - Returns: A new QualifiedNameSyntax with the element at the provided index
  ///            removed.
  public func removing(childAt index: Int) -> QualifiedNameSyntax {
    var newLayout = data.raw.layout
    newLayout.remove(at: index)
    return replacingLayout(newLayout)
  }

  /// Creates a new QualifiedNameSyntax by removing the first element.
  ///
  /// - Returns: A new QualifiedNameSyntax with the first element removed.
  public func removingFirst() -> QualifiedNameSyntax {
    var newLayout = data.raw.layout
    newLayout.removeFirst()
    return replacingLayout(newLayout)
  }

  /// Creates a new QualifiedNameSyntax by removing the last element.
  ///
  /// - Returns: A new QualifiedNameSyntax with the last element removed.
  public func removingLast() -> QualifiedNameSyntax {
    var newLayout = data.raw.layout
    newLayout.removeLast()
    return replacingLayout(newLayout)
  }

  /// Returns an iterator over the elements of this syntax collection.
  public func makeIterator() -> QualifiedNameSyntaxIterator {
    return QualifiedNameSyntaxIterator(collection: self)
  }
}

/// Conformance for QualifiedNameSyntax to the Collection protocol.
extension QualifiedNameSyntax: Collection {
  public var startIndex: Int {
    return data.childCaches.startIndex
  }

  public var endIndex: Int {
    return data.childCaches.endIndex
  }

  public func index(after i: Int) -> Int {
    return data.childCaches.index(after: i)
  }

  public subscript(_ index: Int) -> QualifiedNamePieceSyntax {
    // swiftlint:disable force_cast
    return child(at: index)! as! QualifiedNamePieceSyntax
  }
}

/// A type that iterates over a syntax collection using its indices.
public struct QualifiedNameSyntaxIterator: IteratorProtocol {
  private let collection: QualifiedNameSyntax
  private var index: QualifiedNameSyntax.Index

  fileprivate init(collection: QualifiedNameSyntax) {
    self.collection = collection
    self.index = collection.startIndex
  }

  public mutating func next() -> QualifiedNamePieceSyntax? {
    guard
      !(self.collection.isEmpty || self.index == self.collection.endIndex)
    else {
      return nil
    }

    let result = collection[index]
    collection.formIndex(after: &index)
    return result
  }
}
public struct QualifiedNamePieceSyntax: Syntax, _SyntaxBase {
  let _root: SyntaxData
  unowned let _data: SyntaxData
  public enum Cursor: Int {
    case name
    case trailingPeriod
  }

  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
  }
  public init(name: TokenSyntax, trailingPeriod: TokenSyntax?) {
    let raw = RawSyntax.node(.qualifiedNamePiece, [
      name.raw,
      trailingPeriod?.raw ?? RawSyntax.missingToken(.period),
    ], .present)
    let data = SyntaxData(raw: raw, indexInParent: 0, parent: nil)
    self.init(root: data, data: data)
  }
  public var name: TokenSyntax {
    return child(at: Cursor.name) as! TokenSyntax
  }
  public func withName(_ syntax: TokenSyntax) -> QualifiedNamePieceSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.name)
    return QualifiedNamePieceSyntax(root: newRoot, data: newData)
  }

  public var trailingPeriod: TokenSyntax? {
    return child(at: Cursor.trailingPeriod) as? TokenSyntax
  }
  public func withTrailingPeriod(_ syntax: TokenSyntax) -> QualifiedNamePieceSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.trailingPeriod)
    return QualifiedNamePieceSyntax(root: newRoot, data: newData)
  }

}

public struct ModuleDeclSyntax: DeclSyntax, _SyntaxBase {
  let _root: SyntaxData
  unowned let _data: SyntaxData
  public enum Cursor: Int {
    case moduleToken
    case moduleIdentifier
    case typedParameterList
    case whereToken
    case leftBraceToken
    case declList
    case rightBraceToken
    case trailingSemicolon
  }

  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
  }
  public init(moduleToken: TokenSyntax, moduleIdentifier: QualifiedNameSyntax, typedParameterList: TypedParameterListSyntax, whereToken: TokenSyntax, leftBraceToken: TokenSyntax, declList: DeclListSyntax, rightBraceToken: TokenSyntax, trailingSemicolon: TokenSyntax) {
    let raw = RawSyntax.node(.moduleDecl, [
      moduleToken.raw,
      moduleIdentifier.raw,
      typedParameterList.raw,
      whereToken.raw,
      leftBraceToken.raw,
      declList.raw,
      rightBraceToken.raw,
      trailingSemicolon.raw,
    ], .present)
    let data = SyntaxData(raw: raw, indexInParent: 0, parent: nil)
    self.init(root: data, data: data)
  }
  public var moduleToken: TokenSyntax {
    return child(at: Cursor.moduleToken) as! TokenSyntax
  }
  public func withModuleToken(_ syntax: TokenSyntax) -> ModuleDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.moduleToken)
    return ModuleDeclSyntax(root: newRoot, data: newData)
  }

  public var moduleIdentifier: QualifiedNameSyntax {
    return child(at: Cursor.moduleIdentifier) as! QualifiedNameSyntax
  }
  public func withModuleIdentifier(_ syntax: QualifiedNameSyntax) -> ModuleDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.moduleIdentifier)
    return ModuleDeclSyntax(root: newRoot, data: newData)
  }

  public var typedParameterList: TypedParameterListSyntax {
    return child(at: Cursor.typedParameterList) as! TypedParameterListSyntax
  }
  public func withTypedParameterList(_ syntax: TypedParameterListSyntax) -> ModuleDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.typedParameterList)
    return ModuleDeclSyntax(root: newRoot, data: newData)
  }

  public var whereToken: TokenSyntax {
    return child(at: Cursor.whereToken) as! TokenSyntax
  }
  public func withWhereToken(_ syntax: TokenSyntax) -> ModuleDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.whereToken)
    return ModuleDeclSyntax(root: newRoot, data: newData)
  }

  public var leftBraceToken: TokenSyntax {
    return child(at: Cursor.leftBraceToken) as! TokenSyntax
  }
  public func withLeftBraceToken(_ syntax: TokenSyntax) -> ModuleDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.leftBraceToken)
    return ModuleDeclSyntax(root: newRoot, data: newData)
  }

  public var declList: DeclListSyntax {
    return child(at: Cursor.declList) as! DeclListSyntax
  }
  public func withDeclList(_ syntax: DeclListSyntax) -> ModuleDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.declList)
    return ModuleDeclSyntax(root: newRoot, data: newData)
  }

  public var rightBraceToken: TokenSyntax {
    return child(at: Cursor.rightBraceToken) as! TokenSyntax
  }
  public func withRightBraceToken(_ syntax: TokenSyntax) -> ModuleDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.rightBraceToken)
    return ModuleDeclSyntax(root: newRoot, data: newData)
  }

  public var trailingSemicolon: TokenSyntax {
    return child(at: Cursor.trailingSemicolon) as! TokenSyntax
  }
  public func withTrailingSemicolon(_ syntax: TokenSyntax) -> ModuleDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.trailingSemicolon)
    return ModuleDeclSyntax(root: newRoot, data: newData)
  }

}

public struct DeclListSyntax: _SyntaxBase {
  let _root: SyntaxData
  unowned let _data: SyntaxData

  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
  }

  public init(elements: [DeclSyntax]) {
    let list = elements.map { $0.raw }
    let sd = SyntaxData(raw: .node(.declList, list, .present))
    self._root = sd
    self._data = sd
  }


  /// Creates a new DeclListSyntax by replacing the underlying layout with
  /// a different set of raw syntax nodes.
  ///
  /// - Parameter layout: The new list of raw syntax nodes underlying this
  ///                     collection.
  /// - Returns: A new SyntaxCollection with the new layout underlying it.
  internal func replacingLayout(
    _ layout: [RawSyntax]) -> DeclListSyntax {
    let newRaw = data.raw.replacingLayout(layout)
    let (newRoot, newData) = data.replacingSelf(newRaw)
    return DeclListSyntax(root: newRoot, data: newData)
  }

  /// Creates a new DeclListSyntax by appending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to append.
  /// - Returns: A new SyntaxCollection with that element appended to the end.
  public func appending(
    _ syntax: DeclSyntax) -> DeclListSyntax {
    var newLayout = data.raw.layout
    newLayout.append(syntax.raw)
    return replacingLayout(newLayout)
  }

  /// Creates a new DeclListSyntax by prepending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to prepend.
  /// - Returns: A new SyntaxCollection with that element prepended to the
  ///            beginning.
  public func prepending(
    _ syntax: DeclSyntax) -> DeclListSyntax {
    return inserting(syntax, at: 0)
  }

  /// Creates a new DeclListSyntax by inserting the provided syntax element
  /// at the provided index in the children.
  ///
  /// - Parameters:
  ///   - syntax: The element to insert.
  ///   - index: The index at which to insert the element in the collection.
  ///
  /// - Returns: A new DeclListSyntax with that element appended to the end.
  public func inserting(_ syntax: DeclSyntax,
                        at index: Int) -> DeclListSyntax {
    var newLayout = data.raw.layout
    /// Make sure the index is a valid insertion index (0 to 1 past the end)
    precondition((newLayout.startIndex...newLayout.endIndex).contains(index),
                 "inserting node at invalid index \(index)")
    newLayout.insert(syntax.raw, at: index)
    return replacingLayout(newLayout)
  }

  /// Creates a new DeclListSyntax by removing the syntax element at the
  /// provided index.
  ///
  /// - Parameter index: The index of the element to remove from the collection.
  /// - Returns: A new DeclListSyntax with the element at the provided index
  ///            removed.
  public func removing(childAt index: Int) -> DeclListSyntax {
    var newLayout = data.raw.layout
    newLayout.remove(at: index)
    return replacingLayout(newLayout)
  }

  /// Creates a new DeclListSyntax by removing the first element.
  ///
  /// - Returns: A new DeclListSyntax with the first element removed.
  public func removingFirst() -> DeclListSyntax {
    var newLayout = data.raw.layout
    newLayout.removeFirst()
    return replacingLayout(newLayout)
  }

  /// Creates a new DeclListSyntax by removing the last element.
  ///
  /// - Returns: A new DeclListSyntax with the last element removed.
  public func removingLast() -> DeclListSyntax {
    var newLayout = data.raw.layout
    newLayout.removeLast()
    return replacingLayout(newLayout)
  }

  /// Returns an iterator over the elements of this syntax collection.
  public func makeIterator() -> DeclListSyntaxIterator {
    return DeclListSyntaxIterator(collection: self)
  }
}

/// Conformance for DeclListSyntax to the Collection protocol.
extension DeclListSyntax: Collection {
  public var startIndex: Int {
    return data.childCaches.startIndex
  }

  public var endIndex: Int {
    return data.childCaches.endIndex
  }

  public func index(after i: Int) -> Int {
    return data.childCaches.index(after: i)
  }

  public subscript(_ index: Int) -> DeclSyntax {
    // swiftlint:disable force_cast
    return child(at: index)! as! DeclSyntax
  }
}

/// A type that iterates over a syntax collection using its indices.
public struct DeclListSyntaxIterator: IteratorProtocol {
  private let collection: DeclListSyntax
  private var index: DeclListSyntax.Index

  fileprivate init(collection: DeclListSyntax) {
    self.collection = collection
    self.index = collection.startIndex
  }

  public mutating func next() -> DeclSyntax? {
    guard
      !(self.collection.isEmpty || self.index == self.collection.endIndex)
    else {
      return nil
    }

    let result = collection[index]
    collection.formIndex(after: &index)
    return result
  }
}
public struct OpenImportDeclSyntax: DeclSyntax, _SyntaxBase {
  let _root: SyntaxData
  unowned let _data: SyntaxData
  public enum Cursor: Int {
    case openToken
    case importToken
    case importIdentifier
  }

  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
  }
  public init(openToken: TokenSyntax?, importToken: TokenSyntax, importIdentifier: QualifiedNameSyntax) {
    let raw = RawSyntax.node(.openImportDecl, [
      openToken?.raw ?? RawSyntax.missingToken(.openKeyword),
      importToken.raw,
      importIdentifier.raw,
    ], .present)
    let data = SyntaxData(raw: raw, indexInParent: 0, parent: nil)
    self.init(root: data, data: data)
  }
  public var openToken: TokenSyntax? {
    return child(at: Cursor.openToken) as? TokenSyntax
  }
  public func withOpenToken(_ syntax: TokenSyntax) -> OpenImportDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.openToken)
    return OpenImportDeclSyntax(root: newRoot, data: newData)
  }

  public var importToken: TokenSyntax {
    return child(at: Cursor.importToken) as! TokenSyntax
  }
  public func withImportToken(_ syntax: TokenSyntax) -> OpenImportDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.importToken)
    return OpenImportDeclSyntax(root: newRoot, data: newData)
  }

  public var importIdentifier: QualifiedNameSyntax {
    return child(at: Cursor.importIdentifier) as! QualifiedNameSyntax
  }
  public func withImportIdentifier(_ syntax: QualifiedNameSyntax) -> OpenImportDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.importIdentifier)
    return OpenImportDeclSyntax(root: newRoot, data: newData)
  }

}

public struct ImportDeclSyntax: DeclSyntax, _SyntaxBase {
  let _root: SyntaxData
  unowned let _data: SyntaxData
  public enum Cursor: Int {
    case importToken
    case importIdentifier
  }

  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
  }
  public init(importToken: TokenSyntax, importIdentifier: QualifiedNameSyntax) {
    let raw = RawSyntax.node(.importDecl, [
      importToken.raw,
      importIdentifier.raw,
    ], .present)
    let data = SyntaxData(raw: raw, indexInParent: 0, parent: nil)
    self.init(root: data, data: data)
  }
  public var importToken: TokenSyntax {
    return child(at: Cursor.importToken) as! TokenSyntax
  }
  public func withImportToken(_ syntax: TokenSyntax) -> ImportDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.importToken)
    return ImportDeclSyntax(root: newRoot, data: newData)
  }

  public var importIdentifier: QualifiedNameSyntax {
    return child(at: Cursor.importIdentifier) as! QualifiedNameSyntax
  }
  public func withImportIdentifier(_ syntax: QualifiedNameSyntax) -> ImportDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.importIdentifier)
    return ImportDeclSyntax(root: newRoot, data: newData)
  }

}

public struct DataDeclSyntax: DeclSyntax, _SyntaxBase {
  let _root: SyntaxData
  unowned let _data: SyntaxData
  public enum Cursor: Int {
    case dataToken
    case dataIdentifier
    case typedParameterList
    case typeIndices
    case whereToken
    case leftBraceToken
    case constructorList
    case rightBraceToken
    case trailingSemicolon
  }

  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
  }
  public init(dataToken: TokenSyntax, dataIdentifier: TokenSyntax, typedParameterList: TypedParameterListSyntax, typeIndices: TypeIndicesSyntax, whereToken: TokenSyntax, leftBraceToken: TokenSyntax, constructorList: ConstructorListSyntax, rightBraceToken: TokenSyntax, trailingSemicolon: TokenSyntax) {
    let raw = RawSyntax.node(.dataDecl, [
      dataToken.raw,
      dataIdentifier.raw,
      typedParameterList.raw,
      typeIndices.raw,
      whereToken.raw,
      leftBraceToken.raw,
      constructorList.raw,
      rightBraceToken.raw,
      trailingSemicolon.raw,
    ], .present)
    let data = SyntaxData(raw: raw, indexInParent: 0, parent: nil)
    self.init(root: data, data: data)
  }
  public var dataToken: TokenSyntax {
    return child(at: Cursor.dataToken) as! TokenSyntax
  }
  public func withDataToken(_ syntax: TokenSyntax) -> DataDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.dataToken)
    return DataDeclSyntax(root: newRoot, data: newData)
  }

  public var dataIdentifier: TokenSyntax {
    return child(at: Cursor.dataIdentifier) as! TokenSyntax
  }
  public func withDataIdentifier(_ syntax: TokenSyntax) -> DataDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.dataIdentifier)
    return DataDeclSyntax(root: newRoot, data: newData)
  }

  public var typedParameterList: TypedParameterListSyntax {
    return child(at: Cursor.typedParameterList) as! TypedParameterListSyntax
  }
  public func withTypedParameterList(_ syntax: TypedParameterListSyntax) -> DataDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.typedParameterList)
    return DataDeclSyntax(root: newRoot, data: newData)
  }

  public var typeIndices: TypeIndicesSyntax {
    return child(at: Cursor.typeIndices) as! TypeIndicesSyntax
  }
  public func withTypeIndices(_ syntax: TypeIndicesSyntax) -> DataDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.typeIndices)
    return DataDeclSyntax(root: newRoot, data: newData)
  }

  public var whereToken: TokenSyntax {
    return child(at: Cursor.whereToken) as! TokenSyntax
  }
  public func withWhereToken(_ syntax: TokenSyntax) -> DataDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.whereToken)
    return DataDeclSyntax(root: newRoot, data: newData)
  }

  public var leftBraceToken: TokenSyntax {
    return child(at: Cursor.leftBraceToken) as! TokenSyntax
  }
  public func withLeftBraceToken(_ syntax: TokenSyntax) -> DataDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.leftBraceToken)
    return DataDeclSyntax(root: newRoot, data: newData)
  }

  public var constructorList: ConstructorListSyntax {
    return child(at: Cursor.constructorList) as! ConstructorListSyntax
  }
  public func withConstructorList(_ syntax: ConstructorListSyntax) -> DataDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.constructorList)
    return DataDeclSyntax(root: newRoot, data: newData)
  }

  public var rightBraceToken: TokenSyntax {
    return child(at: Cursor.rightBraceToken) as! TokenSyntax
  }
  public func withRightBraceToken(_ syntax: TokenSyntax) -> DataDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.rightBraceToken)
    return DataDeclSyntax(root: newRoot, data: newData)
  }

  public var trailingSemicolon: TokenSyntax {
    return child(at: Cursor.trailingSemicolon) as! TokenSyntax
  }
  public func withTrailingSemicolon(_ syntax: TokenSyntax) -> DataDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.trailingSemicolon)
    return DataDeclSyntax(root: newRoot, data: newData)
  }

}

public struct EmptyDataDeclSyntax: DeclSyntax, _SyntaxBase {
  let _root: SyntaxData
  unowned let _data: SyntaxData
  public enum Cursor: Int {
    case dataToken
    case dataIdentifier
    case typedParameterList
    case typeIndices
    case trailingSemicolon
  }

  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
  }
  public init(dataToken: TokenSyntax, dataIdentifier: TokenSyntax, typedParameterList: TypedParameterListSyntax, typeIndices: TypeIndicesSyntax, trailingSemicolon: TokenSyntax) {
    let raw = RawSyntax.node(.emptyDataDecl, [
      dataToken.raw,
      dataIdentifier.raw,
      typedParameterList.raw,
      typeIndices.raw,
      trailingSemicolon.raw,
    ], .present)
    let data = SyntaxData(raw: raw, indexInParent: 0, parent: nil)
    self.init(root: data, data: data)
  }
  public var dataToken: TokenSyntax {
    return child(at: Cursor.dataToken) as! TokenSyntax
  }
  public func withDataToken(_ syntax: TokenSyntax) -> EmptyDataDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.dataToken)
    return EmptyDataDeclSyntax(root: newRoot, data: newData)
  }

  public var dataIdentifier: TokenSyntax {
    return child(at: Cursor.dataIdentifier) as! TokenSyntax
  }
  public func withDataIdentifier(_ syntax: TokenSyntax) -> EmptyDataDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.dataIdentifier)
    return EmptyDataDeclSyntax(root: newRoot, data: newData)
  }

  public var typedParameterList: TypedParameterListSyntax {
    return child(at: Cursor.typedParameterList) as! TypedParameterListSyntax
  }
  public func withTypedParameterList(_ syntax: TypedParameterListSyntax) -> EmptyDataDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.typedParameterList)
    return EmptyDataDeclSyntax(root: newRoot, data: newData)
  }

  public var typeIndices: TypeIndicesSyntax {
    return child(at: Cursor.typeIndices) as! TypeIndicesSyntax
  }
  public func withTypeIndices(_ syntax: TypeIndicesSyntax) -> EmptyDataDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.typeIndices)
    return EmptyDataDeclSyntax(root: newRoot, data: newData)
  }

  public var trailingSemicolon: TokenSyntax {
    return child(at: Cursor.trailingSemicolon) as! TokenSyntax
  }
  public func withTrailingSemicolon(_ syntax: TokenSyntax) -> EmptyDataDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.trailingSemicolon)
    return EmptyDataDeclSyntax(root: newRoot, data: newData)
  }

}

public struct TypeIndicesSyntax: Syntax, _SyntaxBase {
  let _root: SyntaxData
  unowned let _data: SyntaxData
  public enum Cursor: Int {
    case colonToken
    case indexExpr
  }

  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
  }
  public init(colonToken: TokenSyntax, indexExpr: ExprSyntax) {
    let raw = RawSyntax.node(.typeIndices, [
      colonToken.raw,
      indexExpr.raw,
    ], .present)
    let data = SyntaxData(raw: raw, indexInParent: 0, parent: nil)
    self.init(root: data, data: data)
  }
  public var colonToken: TokenSyntax {
    return child(at: Cursor.colonToken) as! TokenSyntax
  }
  public func withColonToken(_ syntax: TokenSyntax) -> TypeIndicesSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.colonToken)
    return TypeIndicesSyntax(root: newRoot, data: newData)
  }

  public var indexExpr: ExprSyntax {
    return child(at: Cursor.indexExpr) as! ExprSyntax
  }
  public func withIndexExpr(_ syntax: ExprSyntax) -> TypeIndicesSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.indexExpr)
    return TypeIndicesSyntax(root: newRoot, data: newData)
  }

}

public struct TypedParameterListSyntax: _SyntaxBase {
  let _root: SyntaxData
  unowned let _data: SyntaxData

  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
  }

  public init(elements: [TypedParameterSyntax]) {
    let list = elements.map { $0.raw }
    let sd = SyntaxData(raw: .node(.typedParameterList, list, .present))
    self._root = sd
    self._data = sd
  }


  /// Creates a new TypedParameterListSyntax by replacing the underlying layout with
  /// a different set of raw syntax nodes.
  ///
  /// - Parameter layout: The new list of raw syntax nodes underlying this
  ///                     collection.
  /// - Returns: A new SyntaxCollection with the new layout underlying it.
  internal func replacingLayout(
    _ layout: [RawSyntax]) -> TypedParameterListSyntax {
    let newRaw = data.raw.replacingLayout(layout)
    let (newRoot, newData) = data.replacingSelf(newRaw)
    return TypedParameterListSyntax(root: newRoot, data: newData)
  }

  /// Creates a new TypedParameterListSyntax by appending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to append.
  /// - Returns: A new SyntaxCollection with that element appended to the end.
  public func appending(
    _ syntax: TypedParameterSyntax) -> TypedParameterListSyntax {
    var newLayout = data.raw.layout
    newLayout.append(syntax.raw)
    return replacingLayout(newLayout)
  }

  /// Creates a new TypedParameterListSyntax by prepending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to prepend.
  /// - Returns: A new SyntaxCollection with that element prepended to the
  ///            beginning.
  public func prepending(
    _ syntax: TypedParameterSyntax) -> TypedParameterListSyntax {
    return inserting(syntax, at: 0)
  }

  /// Creates a new TypedParameterListSyntax by inserting the provided syntax element
  /// at the provided index in the children.
  ///
  /// - Parameters:
  ///   - syntax: The element to insert.
  ///   - index: The index at which to insert the element in the collection.
  ///
  /// - Returns: A new TypedParameterListSyntax with that element appended to the end.
  public func inserting(_ syntax: TypedParameterSyntax,
                        at index: Int) -> TypedParameterListSyntax {
    var newLayout = data.raw.layout
    /// Make sure the index is a valid insertion index (0 to 1 past the end)
    precondition((newLayout.startIndex...newLayout.endIndex).contains(index),
                 "inserting node at invalid index \(index)")
    newLayout.insert(syntax.raw, at: index)
    return replacingLayout(newLayout)
  }

  /// Creates a new TypedParameterListSyntax by removing the syntax element at the
  /// provided index.
  ///
  /// - Parameter index: The index of the element to remove from the collection.
  /// - Returns: A new TypedParameterListSyntax with the element at the provided index
  ///            removed.
  public func removing(childAt index: Int) -> TypedParameterListSyntax {
    var newLayout = data.raw.layout
    newLayout.remove(at: index)
    return replacingLayout(newLayout)
  }

  /// Creates a new TypedParameterListSyntax by removing the first element.
  ///
  /// - Returns: A new TypedParameterListSyntax with the first element removed.
  public func removingFirst() -> TypedParameterListSyntax {
    var newLayout = data.raw.layout
    newLayout.removeFirst()
    return replacingLayout(newLayout)
  }

  /// Creates a new TypedParameterListSyntax by removing the last element.
  ///
  /// - Returns: A new TypedParameterListSyntax with the last element removed.
  public func removingLast() -> TypedParameterListSyntax {
    var newLayout = data.raw.layout
    newLayout.removeLast()
    return replacingLayout(newLayout)
  }

  /// Returns an iterator over the elements of this syntax collection.
  public func makeIterator() -> TypedParameterListSyntaxIterator {
    return TypedParameterListSyntaxIterator(collection: self)
  }
}

/// Conformance for TypedParameterListSyntax to the Collection protocol.
extension TypedParameterListSyntax: Collection {
  public var startIndex: Int {
    return data.childCaches.startIndex
  }

  public var endIndex: Int {
    return data.childCaches.endIndex
  }

  public func index(after i: Int) -> Int {
    return data.childCaches.index(after: i)
  }

  public subscript(_ index: Int) -> TypedParameterSyntax {
    // swiftlint:disable force_cast
    return child(at: index)! as! TypedParameterSyntax
  }
}

/// A type that iterates over a syntax collection using its indices.
public struct TypedParameterListSyntaxIterator: IteratorProtocol {
  private let collection: TypedParameterListSyntax
  private var index: TypedParameterListSyntax.Index

  fileprivate init(collection: TypedParameterListSyntax) {
    self.collection = collection
    self.index = collection.startIndex
  }

  public mutating func next() -> TypedParameterSyntax? {
    guard
      !(self.collection.isEmpty || self.index == self.collection.endIndex)
    else {
      return nil
    }

    let result = collection[index]
    collection.formIndex(after: &index)
    return result
  }
}
public struct AscriptionSyntax: Syntax, _SyntaxBase {
  let _root: SyntaxData
  unowned let _data: SyntaxData
  public enum Cursor: Int {
    case boundNames
    case colonToken
    case typeExpr
  }

  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
  }
  public init(boundNames: IdentifierListSyntax, colonToken: TokenSyntax, typeExpr: ExprSyntax) {
    let raw = RawSyntax.node(.ascription, [
      boundNames.raw,
      colonToken.raw,
      typeExpr.raw,
    ], .present)
    let data = SyntaxData(raw: raw, indexInParent: 0, parent: nil)
    self.init(root: data, data: data)
  }
  public var boundNames: IdentifierListSyntax {
    return child(at: Cursor.boundNames) as! IdentifierListSyntax
  }
  public func withBoundNames(_ syntax: IdentifierListSyntax) -> AscriptionSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.boundNames)
    return AscriptionSyntax(root: newRoot, data: newData)
  }

  public var colonToken: TokenSyntax {
    return child(at: Cursor.colonToken) as! TokenSyntax
  }
  public func withColonToken(_ syntax: TokenSyntax) -> AscriptionSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.colonToken)
    return AscriptionSyntax(root: newRoot, data: newData)
  }

  public var typeExpr: ExprSyntax {
    return child(at: Cursor.typeExpr) as! ExprSyntax
  }
  public func withTypeExpr(_ syntax: ExprSyntax) -> AscriptionSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.typeExpr)
    return AscriptionSyntax(root: newRoot, data: newData)
  }

}

public struct ExplicitTypedParameterSyntax: TypedParameterSyntax, _SyntaxBase {
  let _root: SyntaxData
  unowned let _data: SyntaxData
  public enum Cursor: Int {
    case leftParenToken
    case ascription
    case rightParenToken
  }

  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
  }
  public init(leftParenToken: TokenSyntax, ascription: AscriptionSyntax, rightParenToken: TokenSyntax) {
    let raw = RawSyntax.node(.explicitTypedParameter, [
      leftParenToken.raw,
      ascription.raw,
      rightParenToken.raw,
    ], .present)
    let data = SyntaxData(raw: raw, indexInParent: 0, parent: nil)
    self.init(root: data, data: data)
  }
  public var leftParenToken: TokenSyntax {
    return child(at: Cursor.leftParenToken) as! TokenSyntax
  }
  public func withLeftParenToken(_ syntax: TokenSyntax) -> ExplicitTypedParameterSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.leftParenToken)
    return ExplicitTypedParameterSyntax(root: newRoot, data: newData)
  }

  public var ascription: AscriptionSyntax {
    return child(at: Cursor.ascription) as! AscriptionSyntax
  }
  public func withAscription(_ syntax: AscriptionSyntax) -> ExplicitTypedParameterSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.ascription)
    return ExplicitTypedParameterSyntax(root: newRoot, data: newData)
  }

  public var rightParenToken: TokenSyntax {
    return child(at: Cursor.rightParenToken) as! TokenSyntax
  }
  public func withRightParenToken(_ syntax: TokenSyntax) -> ExplicitTypedParameterSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.rightParenToken)
    return ExplicitTypedParameterSyntax(root: newRoot, data: newData)
  }

}

public struct ImplicitTypedParameterSyntax: TypedParameterSyntax, _SyntaxBase {
  let _root: SyntaxData
  unowned let _data: SyntaxData
  public enum Cursor: Int {
    case leftBraceToken
    case ascription
    case rightBraceToken
  }

  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
  }
  public init(leftBraceToken: TokenSyntax, ascription: AscriptionSyntax, rightBraceToken: TokenSyntax) {
    let raw = RawSyntax.node(.implicitTypedParameter, [
      leftBraceToken.raw,
      ascription.raw,
      rightBraceToken.raw,
    ], .present)
    let data = SyntaxData(raw: raw, indexInParent: 0, parent: nil)
    self.init(root: data, data: data)
  }
  public var leftBraceToken: TokenSyntax {
    return child(at: Cursor.leftBraceToken) as! TokenSyntax
  }
  public func withLeftBraceToken(_ syntax: TokenSyntax) -> ImplicitTypedParameterSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.leftBraceToken)
    return ImplicitTypedParameterSyntax(root: newRoot, data: newData)
  }

  public var ascription: AscriptionSyntax {
    return child(at: Cursor.ascription) as! AscriptionSyntax
  }
  public func withAscription(_ syntax: AscriptionSyntax) -> ImplicitTypedParameterSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.ascription)
    return ImplicitTypedParameterSyntax(root: newRoot, data: newData)
  }

  public var rightBraceToken: TokenSyntax {
    return child(at: Cursor.rightBraceToken) as! TokenSyntax
  }
  public func withRightBraceToken(_ syntax: TokenSyntax) -> ImplicitTypedParameterSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.rightBraceToken)
    return ImplicitTypedParameterSyntax(root: newRoot, data: newData)
  }

}

public struct ConstructorListSyntax: _SyntaxBase {
  let _root: SyntaxData
  unowned let _data: SyntaxData

  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
  }

  public init(elements: [ConstructorDeclSyntax]) {
    let list = elements.map { $0.raw }
    let sd = SyntaxData(raw: .node(.constructorList, list, .present))
    self._root = sd
    self._data = sd
  }


  /// Creates a new ConstructorListSyntax by replacing the underlying layout with
  /// a different set of raw syntax nodes.
  ///
  /// - Parameter layout: The new list of raw syntax nodes underlying this
  ///                     collection.
  /// - Returns: A new SyntaxCollection with the new layout underlying it.
  internal func replacingLayout(
    _ layout: [RawSyntax]) -> ConstructorListSyntax {
    let newRaw = data.raw.replacingLayout(layout)
    let (newRoot, newData) = data.replacingSelf(newRaw)
    return ConstructorListSyntax(root: newRoot, data: newData)
  }

  /// Creates a new ConstructorListSyntax by appending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to append.
  /// - Returns: A new SyntaxCollection with that element appended to the end.
  public func appending(
    _ syntax: ConstructorDeclSyntax) -> ConstructorListSyntax {
    var newLayout = data.raw.layout
    newLayout.append(syntax.raw)
    return replacingLayout(newLayout)
  }

  /// Creates a new ConstructorListSyntax by prepending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to prepend.
  /// - Returns: A new SyntaxCollection with that element prepended to the
  ///            beginning.
  public func prepending(
    _ syntax: ConstructorDeclSyntax) -> ConstructorListSyntax {
    return inserting(syntax, at: 0)
  }

  /// Creates a new ConstructorListSyntax by inserting the provided syntax element
  /// at the provided index in the children.
  ///
  /// - Parameters:
  ///   - syntax: The element to insert.
  ///   - index: The index at which to insert the element in the collection.
  ///
  /// - Returns: A new ConstructorListSyntax with that element appended to the end.
  public func inserting(_ syntax: ConstructorDeclSyntax,
                        at index: Int) -> ConstructorListSyntax {
    var newLayout = data.raw.layout
    /// Make sure the index is a valid insertion index (0 to 1 past the end)
    precondition((newLayout.startIndex...newLayout.endIndex).contains(index),
                 "inserting node at invalid index \(index)")
    newLayout.insert(syntax.raw, at: index)
    return replacingLayout(newLayout)
  }

  /// Creates a new ConstructorListSyntax by removing the syntax element at the
  /// provided index.
  ///
  /// - Parameter index: The index of the element to remove from the collection.
  /// - Returns: A new ConstructorListSyntax with the element at the provided index
  ///            removed.
  public func removing(childAt index: Int) -> ConstructorListSyntax {
    var newLayout = data.raw.layout
    newLayout.remove(at: index)
    return replacingLayout(newLayout)
  }

  /// Creates a new ConstructorListSyntax by removing the first element.
  ///
  /// - Returns: A new ConstructorListSyntax with the first element removed.
  public func removingFirst() -> ConstructorListSyntax {
    var newLayout = data.raw.layout
    newLayout.removeFirst()
    return replacingLayout(newLayout)
  }

  /// Creates a new ConstructorListSyntax by removing the last element.
  ///
  /// - Returns: A new ConstructorListSyntax with the last element removed.
  public func removingLast() -> ConstructorListSyntax {
    var newLayout = data.raw.layout
    newLayout.removeLast()
    return replacingLayout(newLayout)
  }

  /// Returns an iterator over the elements of this syntax collection.
  public func makeIterator() -> ConstructorListSyntaxIterator {
    return ConstructorListSyntaxIterator(collection: self)
  }
}

/// Conformance for ConstructorListSyntax to the Collection protocol.
extension ConstructorListSyntax: Collection {
  public var startIndex: Int {
    return data.childCaches.startIndex
  }

  public var endIndex: Int {
    return data.childCaches.endIndex
  }

  public func index(after i: Int) -> Int {
    return data.childCaches.index(after: i)
  }

  public subscript(_ index: Int) -> ConstructorDeclSyntax {
    // swiftlint:disable force_cast
    return child(at: index)! as! ConstructorDeclSyntax
  }
}

/// A type that iterates over a syntax collection using its indices.
public struct ConstructorListSyntaxIterator: IteratorProtocol {
  private let collection: ConstructorListSyntax
  private var index: ConstructorListSyntax.Index

  fileprivate init(collection: ConstructorListSyntax) {
    self.collection = collection
    self.index = collection.startIndex
  }

  public mutating func next() -> ConstructorDeclSyntax? {
    guard
      !(self.collection.isEmpty || self.index == self.collection.endIndex)
    else {
      return nil
    }

    let result = collection[index]
    collection.formIndex(after: &index)
    return result
  }
}
public struct ConstructorDeclSyntax: DeclSyntax, _SyntaxBase {
  let _root: SyntaxData
  unowned let _data: SyntaxData
  public enum Cursor: Int {
    case ascription
    case trailingSemicolon
  }

  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
  }
  public init(ascription: AscriptionSyntax, trailingSemicolon: TokenSyntax) {
    let raw = RawSyntax.node(.constructorDecl, [
      ascription.raw,
      trailingSemicolon.raw,
    ], .present)
    let data = SyntaxData(raw: raw, indexInParent: 0, parent: nil)
    self.init(root: data, data: data)
  }
  public var ascription: AscriptionSyntax {
    return child(at: Cursor.ascription) as! AscriptionSyntax
  }
  public func withAscription(_ syntax: AscriptionSyntax) -> ConstructorDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.ascription)
    return ConstructorDeclSyntax(root: newRoot, data: newData)
  }

  public var trailingSemicolon: TokenSyntax {
    return child(at: Cursor.trailingSemicolon) as! TokenSyntax
  }
  public func withTrailingSemicolon(_ syntax: TokenSyntax) -> ConstructorDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.trailingSemicolon)
    return ConstructorDeclSyntax(root: newRoot, data: newData)
  }

}

public struct RecordDeclSyntax: DeclSyntax, _SyntaxBase {
  let _root: SyntaxData
  unowned let _data: SyntaxData
  public enum Cursor: Int {
    case recordToken
    case recordName
    case parameterList
    case typeIndices
    case whereToken
    case leftParenToken
    case recordElementList
    case rightParenToken
    case trailingSemicolon
  }

  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
  }
  public init(recordToken: TokenSyntax, recordName: TokenSyntax, parameterList: TypedParameterListSyntax, typeIndices: TypeIndicesSyntax, whereToken: TokenSyntax, leftParenToken: TokenSyntax, recordElementList: DeclListSyntax, rightParenToken: TokenSyntax, trailingSemicolon: TokenSyntax) {
    let raw = RawSyntax.node(.recordDecl, [
      recordToken.raw,
      recordName.raw,
      parameterList.raw,
      typeIndices.raw,
      whereToken.raw,
      leftParenToken.raw,
      recordElementList.raw,
      rightParenToken.raw,
      trailingSemicolon.raw,
    ], .present)
    let data = SyntaxData(raw: raw, indexInParent: 0, parent: nil)
    self.init(root: data, data: data)
  }
  public var recordToken: TokenSyntax {
    return child(at: Cursor.recordToken) as! TokenSyntax
  }
  public func withRecordToken(_ syntax: TokenSyntax) -> RecordDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.recordToken)
    return RecordDeclSyntax(root: newRoot, data: newData)
  }

  public var recordName: TokenSyntax {
    return child(at: Cursor.recordName) as! TokenSyntax
  }
  public func withRecordName(_ syntax: TokenSyntax) -> RecordDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.recordName)
    return RecordDeclSyntax(root: newRoot, data: newData)
  }

  public var parameterList: TypedParameterListSyntax {
    return child(at: Cursor.parameterList) as! TypedParameterListSyntax
  }
  public func withParameterList(_ syntax: TypedParameterListSyntax) -> RecordDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.parameterList)
    return RecordDeclSyntax(root: newRoot, data: newData)
  }

  public var typeIndices: TypeIndicesSyntax {
    return child(at: Cursor.typeIndices) as! TypeIndicesSyntax
  }
  public func withTypeIndices(_ syntax: TypeIndicesSyntax) -> RecordDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.typeIndices)
    return RecordDeclSyntax(root: newRoot, data: newData)
  }

  public var whereToken: TokenSyntax {
    return child(at: Cursor.whereToken) as! TokenSyntax
  }
  public func withWhereToken(_ syntax: TokenSyntax) -> RecordDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.whereToken)
    return RecordDeclSyntax(root: newRoot, data: newData)
  }

  public var leftParenToken: TokenSyntax {
    return child(at: Cursor.leftParenToken) as! TokenSyntax
  }
  public func withLeftParenToken(_ syntax: TokenSyntax) -> RecordDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.leftParenToken)
    return RecordDeclSyntax(root: newRoot, data: newData)
  }

  public var recordElementList: DeclListSyntax {
    return child(at: Cursor.recordElementList) as! DeclListSyntax
  }
  public func withRecordElementList(_ syntax: DeclListSyntax) -> RecordDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.recordElementList)
    return RecordDeclSyntax(root: newRoot, data: newData)
  }

  public var rightParenToken: TokenSyntax {
    return child(at: Cursor.rightParenToken) as! TokenSyntax
  }
  public func withRightParenToken(_ syntax: TokenSyntax) -> RecordDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.rightParenToken)
    return RecordDeclSyntax(root: newRoot, data: newData)
  }

  public var trailingSemicolon: TokenSyntax {
    return child(at: Cursor.trailingSemicolon) as! TokenSyntax
  }
  public func withTrailingSemicolon(_ syntax: TokenSyntax) -> RecordDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.trailingSemicolon)
    return RecordDeclSyntax(root: newRoot, data: newData)
  }

}

public struct FieldDeclSyntax: DeclSyntax, _SyntaxBase {
  let _root: SyntaxData
  unowned let _data: SyntaxData
  public enum Cursor: Int {
    case fieldToken
    case ascription
    case trailingSemicolon
  }

  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
  }
  public init(fieldToken: TokenSyntax, ascription: AscriptionSyntax, trailingSemicolon: TokenSyntax) {
    let raw = RawSyntax.node(.fieldDecl, [
      fieldToken.raw,
      ascription.raw,
      trailingSemicolon.raw,
    ], .present)
    let data = SyntaxData(raw: raw, indexInParent: 0, parent: nil)
    self.init(root: data, data: data)
  }
  public var fieldToken: TokenSyntax {
    return child(at: Cursor.fieldToken) as! TokenSyntax
  }
  public func withFieldToken(_ syntax: TokenSyntax) -> FieldDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.fieldToken)
    return FieldDeclSyntax(root: newRoot, data: newData)
  }

  public var ascription: AscriptionSyntax {
    return child(at: Cursor.ascription) as! AscriptionSyntax
  }
  public func withAscription(_ syntax: AscriptionSyntax) -> FieldDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.ascription)
    return FieldDeclSyntax(root: newRoot, data: newData)
  }

  public var trailingSemicolon: TokenSyntax {
    return child(at: Cursor.trailingSemicolon) as! TokenSyntax
  }
  public func withTrailingSemicolon(_ syntax: TokenSyntax) -> FieldDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.trailingSemicolon)
    return FieldDeclSyntax(root: newRoot, data: newData)
  }

}

public struct RecordConstructorDeclSyntax: DeclSyntax, _SyntaxBase {
  let _root: SyntaxData
  unowned let _data: SyntaxData
  public enum Cursor: Int {
    case constructorToken
    case constructorName
    case trailingSemicolon
  }

  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
  }
  public init(constructorToken: TokenSyntax, constructorName: TokenSyntax, trailingSemicolon: TokenSyntax) {
    let raw = RawSyntax.node(.recordConstructorDecl, [
      constructorToken.raw,
      constructorName.raw,
      trailingSemicolon.raw,
    ], .present)
    let data = SyntaxData(raw: raw, indexInParent: 0, parent: nil)
    self.init(root: data, data: data)
  }
  public var constructorToken: TokenSyntax {
    return child(at: Cursor.constructorToken) as! TokenSyntax
  }
  public func withConstructorToken(_ syntax: TokenSyntax) -> RecordConstructorDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.constructorToken)
    return RecordConstructorDeclSyntax(root: newRoot, data: newData)
  }

  public var constructorName: TokenSyntax {
    return child(at: Cursor.constructorName) as! TokenSyntax
  }
  public func withConstructorName(_ syntax: TokenSyntax) -> RecordConstructorDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.constructorName)
    return RecordConstructorDeclSyntax(root: newRoot, data: newData)
  }

  public var trailingSemicolon: TokenSyntax {
    return child(at: Cursor.trailingSemicolon) as! TokenSyntax
  }
  public func withTrailingSemicolon(_ syntax: TokenSyntax) -> RecordConstructorDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.trailingSemicolon)
    return RecordConstructorDeclSyntax(root: newRoot, data: newData)
  }

}

public struct RecordFieldAssignmentListSyntax: _SyntaxBase {
  let _root: SyntaxData
  unowned let _data: SyntaxData

  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
  }

  public init(elements: [RecordFieldAssignmentSyntax]) {
    let list = elements.map { $0.raw }
    let sd = SyntaxData(raw: .node(.recordFieldAssignmentList, list, .present))
    self._root = sd
    self._data = sd
  }


  /// Creates a new RecordFieldAssignmentListSyntax by replacing the underlying layout with
  /// a different set of raw syntax nodes.
  ///
  /// - Parameter layout: The new list of raw syntax nodes underlying this
  ///                     collection.
  /// - Returns: A new SyntaxCollection with the new layout underlying it.
  internal func replacingLayout(
    _ layout: [RawSyntax]) -> RecordFieldAssignmentListSyntax {
    let newRaw = data.raw.replacingLayout(layout)
    let (newRoot, newData) = data.replacingSelf(newRaw)
    return RecordFieldAssignmentListSyntax(root: newRoot, data: newData)
  }

  /// Creates a new RecordFieldAssignmentListSyntax by appending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to append.
  /// - Returns: A new SyntaxCollection with that element appended to the end.
  public func appending(
    _ syntax: RecordFieldAssignmentSyntax) -> RecordFieldAssignmentListSyntax {
    var newLayout = data.raw.layout
    newLayout.append(syntax.raw)
    return replacingLayout(newLayout)
  }

  /// Creates a new RecordFieldAssignmentListSyntax by prepending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to prepend.
  /// - Returns: A new SyntaxCollection with that element prepended to the
  ///            beginning.
  public func prepending(
    _ syntax: RecordFieldAssignmentSyntax) -> RecordFieldAssignmentListSyntax {
    return inserting(syntax, at: 0)
  }

  /// Creates a new RecordFieldAssignmentListSyntax by inserting the provided syntax element
  /// at the provided index in the children.
  ///
  /// - Parameters:
  ///   - syntax: The element to insert.
  ///   - index: The index at which to insert the element in the collection.
  ///
  /// - Returns: A new RecordFieldAssignmentListSyntax with that element appended to the end.
  public func inserting(_ syntax: RecordFieldAssignmentSyntax,
                        at index: Int) -> RecordFieldAssignmentListSyntax {
    var newLayout = data.raw.layout
    /// Make sure the index is a valid insertion index (0 to 1 past the end)
    precondition((newLayout.startIndex...newLayout.endIndex).contains(index),
                 "inserting node at invalid index \(index)")
    newLayout.insert(syntax.raw, at: index)
    return replacingLayout(newLayout)
  }

  /// Creates a new RecordFieldAssignmentListSyntax by removing the syntax element at the
  /// provided index.
  ///
  /// - Parameter index: The index of the element to remove from the collection.
  /// - Returns: A new RecordFieldAssignmentListSyntax with the element at the provided index
  ///            removed.
  public func removing(childAt index: Int) -> RecordFieldAssignmentListSyntax {
    var newLayout = data.raw.layout
    newLayout.remove(at: index)
    return replacingLayout(newLayout)
  }

  /// Creates a new RecordFieldAssignmentListSyntax by removing the first element.
  ///
  /// - Returns: A new RecordFieldAssignmentListSyntax with the first element removed.
  public func removingFirst() -> RecordFieldAssignmentListSyntax {
    var newLayout = data.raw.layout
    newLayout.removeFirst()
    return replacingLayout(newLayout)
  }

  /// Creates a new RecordFieldAssignmentListSyntax by removing the last element.
  ///
  /// - Returns: A new RecordFieldAssignmentListSyntax with the last element removed.
  public func removingLast() -> RecordFieldAssignmentListSyntax {
    var newLayout = data.raw.layout
    newLayout.removeLast()
    return replacingLayout(newLayout)
  }

  /// Returns an iterator over the elements of this syntax collection.
  public func makeIterator() -> RecordFieldAssignmentListSyntaxIterator {
    return RecordFieldAssignmentListSyntaxIterator(collection: self)
  }
}

/// Conformance for RecordFieldAssignmentListSyntax to the Collection protocol.
extension RecordFieldAssignmentListSyntax: Collection {
  public var startIndex: Int {
    return data.childCaches.startIndex
  }

  public var endIndex: Int {
    return data.childCaches.endIndex
  }

  public func index(after i: Int) -> Int {
    return data.childCaches.index(after: i)
  }

  public subscript(_ index: Int) -> RecordFieldAssignmentSyntax {
    // swiftlint:disable force_cast
    return child(at: index)! as! RecordFieldAssignmentSyntax
  }
}

/// A type that iterates over a syntax collection using its indices.
public struct RecordFieldAssignmentListSyntaxIterator: IteratorProtocol {
  private let collection: RecordFieldAssignmentListSyntax
  private var index: RecordFieldAssignmentListSyntax.Index

  fileprivate init(collection: RecordFieldAssignmentListSyntax) {
    self.collection = collection
    self.index = collection.startIndex
  }

  public mutating func next() -> RecordFieldAssignmentSyntax? {
    guard
      !(self.collection.isEmpty || self.index == self.collection.endIndex)
    else {
      return nil
    }

    let result = collection[index]
    collection.formIndex(after: &index)
    return result
  }
}
public struct RecordFieldAssignmentSyntax: Syntax, _SyntaxBase {
  let _root: SyntaxData
  unowned let _data: SyntaxData
  public enum Cursor: Int {
    case fieldName
    case equalsToken
    case fieldInitExpr
    case trailingSemicolon
  }

  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
  }
  public init(fieldName: TokenSyntax, equalsToken: TokenSyntax, fieldInitExpr: ExprSyntax, trailingSemicolon: TokenSyntax?) {
    let raw = RawSyntax.node(.recordFieldAssignment, [
      fieldName.raw,
      equalsToken.raw,
      fieldInitExpr.raw,
      trailingSemicolon?.raw ?? RawSyntax.missingToken(.semicolon),
    ], .present)
    let data = SyntaxData(raw: raw, indexInParent: 0, parent: nil)
    self.init(root: data, data: data)
  }
  public var fieldName: TokenSyntax {
    return child(at: Cursor.fieldName) as! TokenSyntax
  }
  public func withFieldName(_ syntax: TokenSyntax) -> RecordFieldAssignmentSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.fieldName)
    return RecordFieldAssignmentSyntax(root: newRoot, data: newData)
  }

  public var equalsToken: TokenSyntax {
    return child(at: Cursor.equalsToken) as! TokenSyntax
  }
  public func withEqualsToken(_ syntax: TokenSyntax) -> RecordFieldAssignmentSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.equalsToken)
    return RecordFieldAssignmentSyntax(root: newRoot, data: newData)
  }

  public var fieldInitExpr: ExprSyntax {
    return child(at: Cursor.fieldInitExpr) as! ExprSyntax
  }
  public func withFieldInitExpr(_ syntax: ExprSyntax) -> RecordFieldAssignmentSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.fieldInitExpr)
    return RecordFieldAssignmentSyntax(root: newRoot, data: newData)
  }

  public var trailingSemicolon: TokenSyntax? {
    return child(at: Cursor.trailingSemicolon) as? TokenSyntax
  }
  public func withTrailingSemicolon(_ syntax: TokenSyntax) -> RecordFieldAssignmentSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.trailingSemicolon)
    return RecordFieldAssignmentSyntax(root: newRoot, data: newData)
  }

}

public struct FunctionDeclSyntax: DeclSyntax, _SyntaxBase {
  let _root: SyntaxData
  unowned let _data: SyntaxData
  public enum Cursor: Int {
    case ascription
    case trailingSemicolon
  }

  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
  }
  public init(ascription: AscriptionSyntax, trailingSemicolon: TokenSyntax) {
    let raw = RawSyntax.node(.functionDecl, [
      ascription.raw,
      trailingSemicolon.raw,
    ], .present)
    let data = SyntaxData(raw: raw, indexInParent: 0, parent: nil)
    self.init(root: data, data: data)
  }
  public var ascription: AscriptionSyntax {
    return child(at: Cursor.ascription) as! AscriptionSyntax
  }
  public func withAscription(_ syntax: AscriptionSyntax) -> FunctionDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.ascription)
    return FunctionDeclSyntax(root: newRoot, data: newData)
  }

  public var trailingSemicolon: TokenSyntax {
    return child(at: Cursor.trailingSemicolon) as! TokenSyntax
  }
  public func withTrailingSemicolon(_ syntax: TokenSyntax) -> FunctionDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.trailingSemicolon)
    return FunctionDeclSyntax(root: newRoot, data: newData)
  }

}

public struct WithRuleFunctionClauseDeclSyntax: FunctionClauseDeclSyntax, _SyntaxBase {
  let _root: SyntaxData
  unowned let _data: SyntaxData
  public enum Cursor: Int {
    case basicExprList
    case withToken
    case withExpr
    case withPatternClause
    case equalsToken
    case rhsExpr
    case trailingSemicolon
  }

  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
  }
  public init(basicExprList: BasicExprListSyntax, withToken: TokenSyntax, withExpr: ExprSyntax, withPatternClause: BasicExprListSyntax?, equalsToken: TokenSyntax, rhsExpr: ExprSyntax, trailingSemicolon: TokenSyntax) {
    let raw = RawSyntax.node(.withRuleFunctionClauseDecl, [
      basicExprList.raw,
      withToken.raw,
      withExpr.raw,
      withPatternClause?.raw ?? RawSyntax.missing(.basicExprList),
      equalsToken.raw,
      rhsExpr.raw,
      trailingSemicolon.raw,
    ], .present)
    let data = SyntaxData(raw: raw, indexInParent: 0, parent: nil)
    self.init(root: data, data: data)
  }
  public var basicExprList: BasicExprListSyntax {
    return child(at: Cursor.basicExprList) as! BasicExprListSyntax
  }
  public func withBasicExprList(_ syntax: BasicExprListSyntax) -> WithRuleFunctionClauseDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.basicExprList)
    return WithRuleFunctionClauseDeclSyntax(root: newRoot, data: newData)
  }

  public var withToken: TokenSyntax {
    return child(at: Cursor.withToken) as! TokenSyntax
  }
  public func withWithToken(_ syntax: TokenSyntax) -> WithRuleFunctionClauseDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.withToken)
    return WithRuleFunctionClauseDeclSyntax(root: newRoot, data: newData)
  }

  public var withExpr: ExprSyntax {
    return child(at: Cursor.withExpr) as! ExprSyntax
  }
  public func withWithExpr(_ syntax: ExprSyntax) -> WithRuleFunctionClauseDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.withExpr)
    return WithRuleFunctionClauseDeclSyntax(root: newRoot, data: newData)
  }

  public var withPatternClause: BasicExprListSyntax? {
    return child(at: Cursor.withPatternClause) as? BasicExprListSyntax
  }
  public func withWithPatternClause(_ syntax: BasicExprListSyntax) -> WithRuleFunctionClauseDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.withPatternClause)
    return WithRuleFunctionClauseDeclSyntax(root: newRoot, data: newData)
  }

  public var equalsToken: TokenSyntax {
    return child(at: Cursor.equalsToken) as! TokenSyntax
  }
  public func withEqualsToken(_ syntax: TokenSyntax) -> WithRuleFunctionClauseDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.equalsToken)
    return WithRuleFunctionClauseDeclSyntax(root: newRoot, data: newData)
  }

  public var rhsExpr: ExprSyntax {
    return child(at: Cursor.rhsExpr) as! ExprSyntax
  }
  public func withRhsExpr(_ syntax: ExprSyntax) -> WithRuleFunctionClauseDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.rhsExpr)
    return WithRuleFunctionClauseDeclSyntax(root: newRoot, data: newData)
  }

  public var trailingSemicolon: TokenSyntax {
    return child(at: Cursor.trailingSemicolon) as! TokenSyntax
  }
  public func withTrailingSemicolon(_ syntax: TokenSyntax) -> WithRuleFunctionClauseDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.trailingSemicolon)
    return WithRuleFunctionClauseDeclSyntax(root: newRoot, data: newData)
  }

}

public struct NormalFunctionClauseDeclSyntax: FunctionClauseDeclSyntax, _SyntaxBase {
  let _root: SyntaxData
  unowned let _data: SyntaxData
  public enum Cursor: Int {
    case basicExprList
    case equalsToken
    case rhsExpr
    case trailingSemicolon
  }

  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
  }
  public init(basicExprList: BasicExprListSyntax, equalsToken: TokenSyntax, rhsExpr: ExprSyntax, trailingSemicolon: TokenSyntax) {
    let raw = RawSyntax.node(.normalFunctionClauseDecl, [
      basicExprList.raw,
      equalsToken.raw,
      rhsExpr.raw,
      trailingSemicolon.raw,
    ], .present)
    let data = SyntaxData(raw: raw, indexInParent: 0, parent: nil)
    self.init(root: data, data: data)
  }
  public var basicExprList: BasicExprListSyntax {
    return child(at: Cursor.basicExprList) as! BasicExprListSyntax
  }
  public func withBasicExprList(_ syntax: BasicExprListSyntax) -> NormalFunctionClauseDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.basicExprList)
    return NormalFunctionClauseDeclSyntax(root: newRoot, data: newData)
  }

  public var equalsToken: TokenSyntax {
    return child(at: Cursor.equalsToken) as! TokenSyntax
  }
  public func withEqualsToken(_ syntax: TokenSyntax) -> NormalFunctionClauseDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.equalsToken)
    return NormalFunctionClauseDeclSyntax(root: newRoot, data: newData)
  }

  public var rhsExpr: ExprSyntax {
    return child(at: Cursor.rhsExpr) as! ExprSyntax
  }
  public func withRhsExpr(_ syntax: ExprSyntax) -> NormalFunctionClauseDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.rhsExpr)
    return NormalFunctionClauseDeclSyntax(root: newRoot, data: newData)
  }

  public var trailingSemicolon: TokenSyntax {
    return child(at: Cursor.trailingSemicolon) as! TokenSyntax
  }
  public func withTrailingSemicolon(_ syntax: TokenSyntax) -> NormalFunctionClauseDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.trailingSemicolon)
    return NormalFunctionClauseDeclSyntax(root: newRoot, data: newData)
  }

}

public struct LetBindingDeclSyntax: DeclSyntax, _SyntaxBase {
  let _root: SyntaxData
  unowned let _data: SyntaxData
  public enum Cursor: Int {
    case head
    case basicExprList
    case equalsToken
    case boundExpr
    case trailingSemicolon
  }

  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
  }
  public init(head: NamedBasicExprSyntax, basicExprList: BasicExprListSyntax, equalsToken: TokenSyntax, boundExpr: ExprSyntax, trailingSemicolon: TokenSyntax) {
    let raw = RawSyntax.node(.letBindingDecl, [
      head.raw,
      basicExprList.raw,
      equalsToken.raw,
      boundExpr.raw,
      trailingSemicolon.raw,
    ], .present)
    let data = SyntaxData(raw: raw, indexInParent: 0, parent: nil)
    self.init(root: data, data: data)
  }
  public var head: NamedBasicExprSyntax {
    return child(at: Cursor.head) as! NamedBasicExprSyntax
  }
  public func withHead(_ syntax: NamedBasicExprSyntax) -> LetBindingDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.head)
    return LetBindingDeclSyntax(root: newRoot, data: newData)
  }

  public var basicExprList: BasicExprListSyntax {
    return child(at: Cursor.basicExprList) as! BasicExprListSyntax
  }
  public func withBasicExprList(_ syntax: BasicExprListSyntax) -> LetBindingDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.basicExprList)
    return LetBindingDeclSyntax(root: newRoot, data: newData)
  }

  public var equalsToken: TokenSyntax {
    return child(at: Cursor.equalsToken) as! TokenSyntax
  }
  public func withEqualsToken(_ syntax: TokenSyntax) -> LetBindingDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.equalsToken)
    return LetBindingDeclSyntax(root: newRoot, data: newData)
  }

  public var boundExpr: ExprSyntax {
    return child(at: Cursor.boundExpr) as! ExprSyntax
  }
  public func withBoundExpr(_ syntax: ExprSyntax) -> LetBindingDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.boundExpr)
    return LetBindingDeclSyntax(root: newRoot, data: newData)
  }

  public var trailingSemicolon: TokenSyntax {
    return child(at: Cursor.trailingSemicolon) as! TokenSyntax
  }
  public func withTrailingSemicolon(_ syntax: TokenSyntax) -> LetBindingDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.trailingSemicolon)
    return LetBindingDeclSyntax(root: newRoot, data: newData)
  }

}

public struct NonFixDeclSyntax: FixityDeclSyntax, _SyntaxBase {
  let _root: SyntaxData
  unowned let _data: SyntaxData
  public enum Cursor: Int {
    case infixToken
    case precedence
    case names
    case trailingSemicolon
  }

  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
  }
  public init(infixToken: TokenSyntax, precedence: TokenSyntax, names: IdentifierListSyntax, trailingSemicolon: TokenSyntax) {
    let raw = RawSyntax.node(.nonFixDecl, [
      infixToken.raw,
      precedence.raw,
      names.raw,
      trailingSemicolon.raw,
    ], .present)
    let data = SyntaxData(raw: raw, indexInParent: 0, parent: nil)
    self.init(root: data, data: data)
  }
  public var infixToken: TokenSyntax {
    return child(at: Cursor.infixToken) as! TokenSyntax
  }
  public func withInfixToken(_ syntax: TokenSyntax) -> NonFixDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.infixToken)
    return NonFixDeclSyntax(root: newRoot, data: newData)
  }

  public var precedence: TokenSyntax {
    return child(at: Cursor.precedence) as! TokenSyntax
  }
  public func withPrecedence(_ syntax: TokenSyntax) -> NonFixDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.precedence)
    return NonFixDeclSyntax(root: newRoot, data: newData)
  }

  public var names: IdentifierListSyntax {
    return child(at: Cursor.names) as! IdentifierListSyntax
  }
  public func withNames(_ syntax: IdentifierListSyntax) -> NonFixDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.names)
    return NonFixDeclSyntax(root: newRoot, data: newData)
  }

  public var trailingSemicolon: TokenSyntax {
    return child(at: Cursor.trailingSemicolon) as! TokenSyntax
  }
  public func withTrailingSemicolon(_ syntax: TokenSyntax) -> NonFixDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.trailingSemicolon)
    return NonFixDeclSyntax(root: newRoot, data: newData)
  }

}

public struct LeftFixDeclSyntax: FixityDeclSyntax, _SyntaxBase {
  let _root: SyntaxData
  unowned let _data: SyntaxData
  public enum Cursor: Int {
    case infixlToken
    case precedence
    case names
    case trailingSemicolon
  }

  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
  }
  public init(infixlToken: TokenSyntax, precedence: TokenSyntax, names: IdentifierListSyntax, trailingSemicolon: TokenSyntax) {
    let raw = RawSyntax.node(.leftFixDecl, [
      infixlToken.raw,
      precedence.raw,
      names.raw,
      trailingSemicolon.raw,
    ], .present)
    let data = SyntaxData(raw: raw, indexInParent: 0, parent: nil)
    self.init(root: data, data: data)
  }
  public var infixlToken: TokenSyntax {
    return child(at: Cursor.infixlToken) as! TokenSyntax
  }
  public func withInfixlToken(_ syntax: TokenSyntax) -> LeftFixDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.infixlToken)
    return LeftFixDeclSyntax(root: newRoot, data: newData)
  }

  public var precedence: TokenSyntax {
    return child(at: Cursor.precedence) as! TokenSyntax
  }
  public func withPrecedence(_ syntax: TokenSyntax) -> LeftFixDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.precedence)
    return LeftFixDeclSyntax(root: newRoot, data: newData)
  }

  public var names: IdentifierListSyntax {
    return child(at: Cursor.names) as! IdentifierListSyntax
  }
  public func withNames(_ syntax: IdentifierListSyntax) -> LeftFixDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.names)
    return LeftFixDeclSyntax(root: newRoot, data: newData)
  }

  public var trailingSemicolon: TokenSyntax {
    return child(at: Cursor.trailingSemicolon) as! TokenSyntax
  }
  public func withTrailingSemicolon(_ syntax: TokenSyntax) -> LeftFixDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.trailingSemicolon)
    return LeftFixDeclSyntax(root: newRoot, data: newData)
  }

}

public struct RightFixDeclSyntax: FixityDeclSyntax, _SyntaxBase {
  let _root: SyntaxData
  unowned let _data: SyntaxData
  public enum Cursor: Int {
    case infixrToken
    case precedence
    case names
    case trailingSemicolon
  }

  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
  }
  public init(infixrToken: TokenSyntax, precedence: TokenSyntax, names: IdentifierListSyntax, trailingSemicolon: TokenSyntax) {
    let raw = RawSyntax.node(.rightFixDecl, [
      infixrToken.raw,
      precedence.raw,
      names.raw,
      trailingSemicolon.raw,
    ], .present)
    let data = SyntaxData(raw: raw, indexInParent: 0, parent: nil)
    self.init(root: data, data: data)
  }
  public var infixrToken: TokenSyntax {
    return child(at: Cursor.infixrToken) as! TokenSyntax
  }
  public func withInfixrToken(_ syntax: TokenSyntax) -> RightFixDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.infixrToken)
    return RightFixDeclSyntax(root: newRoot, data: newData)
  }

  public var precedence: TokenSyntax {
    return child(at: Cursor.precedence) as! TokenSyntax
  }
  public func withPrecedence(_ syntax: TokenSyntax) -> RightFixDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.precedence)
    return RightFixDeclSyntax(root: newRoot, data: newData)
  }

  public var names: IdentifierListSyntax {
    return child(at: Cursor.names) as! IdentifierListSyntax
  }
  public func withNames(_ syntax: IdentifierListSyntax) -> RightFixDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.names)
    return RightFixDeclSyntax(root: newRoot, data: newData)
  }

  public var trailingSemicolon: TokenSyntax {
    return child(at: Cursor.trailingSemicolon) as! TokenSyntax
  }
  public func withTrailingSemicolon(_ syntax: TokenSyntax) -> RightFixDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.trailingSemicolon)
    return RightFixDeclSyntax(root: newRoot, data: newData)
  }

}

public struct PatternClauseListSyntax: _SyntaxBase {
  let _root: SyntaxData
  unowned let _data: SyntaxData

  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
  }

  public init(elements: [ExprSyntax]) {
    let list = elements.map { $0.raw }
    let sd = SyntaxData(raw: .node(.patternClauseList, list, .present))
    self._root = sd
    self._data = sd
  }


  /// Creates a new PatternClauseListSyntax by replacing the underlying layout with
  /// a different set of raw syntax nodes.
  ///
  /// - Parameter layout: The new list of raw syntax nodes underlying this
  ///                     collection.
  /// - Returns: A new SyntaxCollection with the new layout underlying it.
  internal func replacingLayout(
    _ layout: [RawSyntax]) -> PatternClauseListSyntax {
    let newRaw = data.raw.replacingLayout(layout)
    let (newRoot, newData) = data.replacingSelf(newRaw)
    return PatternClauseListSyntax(root: newRoot, data: newData)
  }

  /// Creates a new PatternClauseListSyntax by appending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to append.
  /// - Returns: A new SyntaxCollection with that element appended to the end.
  public func appending(
    _ syntax: ExprSyntax) -> PatternClauseListSyntax {
    var newLayout = data.raw.layout
    newLayout.append(syntax.raw)
    return replacingLayout(newLayout)
  }

  /// Creates a new PatternClauseListSyntax by prepending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to prepend.
  /// - Returns: A new SyntaxCollection with that element prepended to the
  ///            beginning.
  public func prepending(
    _ syntax: ExprSyntax) -> PatternClauseListSyntax {
    return inserting(syntax, at: 0)
  }

  /// Creates a new PatternClauseListSyntax by inserting the provided syntax element
  /// at the provided index in the children.
  ///
  /// - Parameters:
  ///   - syntax: The element to insert.
  ///   - index: The index at which to insert the element in the collection.
  ///
  /// - Returns: A new PatternClauseListSyntax with that element appended to the end.
  public func inserting(_ syntax: ExprSyntax,
                        at index: Int) -> PatternClauseListSyntax {
    var newLayout = data.raw.layout
    /// Make sure the index is a valid insertion index (0 to 1 past the end)
    precondition((newLayout.startIndex...newLayout.endIndex).contains(index),
                 "inserting node at invalid index \(index)")
    newLayout.insert(syntax.raw, at: index)
    return replacingLayout(newLayout)
  }

  /// Creates a new PatternClauseListSyntax by removing the syntax element at the
  /// provided index.
  ///
  /// - Parameter index: The index of the element to remove from the collection.
  /// - Returns: A new PatternClauseListSyntax with the element at the provided index
  ///            removed.
  public func removing(childAt index: Int) -> PatternClauseListSyntax {
    var newLayout = data.raw.layout
    newLayout.remove(at: index)
    return replacingLayout(newLayout)
  }

  /// Creates a new PatternClauseListSyntax by removing the first element.
  ///
  /// - Returns: A new PatternClauseListSyntax with the first element removed.
  public func removingFirst() -> PatternClauseListSyntax {
    var newLayout = data.raw.layout
    newLayout.removeFirst()
    return replacingLayout(newLayout)
  }

  /// Creates a new PatternClauseListSyntax by removing the last element.
  ///
  /// - Returns: A new PatternClauseListSyntax with the last element removed.
  public func removingLast() -> PatternClauseListSyntax {
    var newLayout = data.raw.layout
    newLayout.removeLast()
    return replacingLayout(newLayout)
  }

  /// Returns an iterator over the elements of this syntax collection.
  public func makeIterator() -> PatternClauseListSyntaxIterator {
    return PatternClauseListSyntaxIterator(collection: self)
  }
}

/// Conformance for PatternClauseListSyntax to the Collection protocol.
extension PatternClauseListSyntax: Collection {
  public var startIndex: Int {
    return data.childCaches.startIndex
  }

  public var endIndex: Int {
    return data.childCaches.endIndex
  }

  public func index(after i: Int) -> Int {
    return data.childCaches.index(after: i)
  }

  public subscript(_ index: Int) -> ExprSyntax {
    // swiftlint:disable force_cast
    return child(at: index)! as! ExprSyntax
  }
}

/// A type that iterates over a syntax collection using its indices.
public struct PatternClauseListSyntaxIterator: IteratorProtocol {
  private let collection: PatternClauseListSyntax
  private var index: PatternClauseListSyntax.Index

  fileprivate init(collection: PatternClauseListSyntax) {
    self.collection = collection
    self.index = collection.startIndex
  }

  public mutating func next() -> ExprSyntax? {
    guard
      !(self.collection.isEmpty || self.index == self.collection.endIndex)
    else {
      return nil
    }

    let result = collection[index]
    collection.formIndex(after: &index)
    return result
  }
}
public struct LambdaExprSyntax: ExprSyntax, _SyntaxBase {
  let _root: SyntaxData
  unowned let _data: SyntaxData
  public enum Cursor: Int {
    case slashToken
    case bindingList
    case arrowToken
    case bodyExpr
  }

  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
  }
  public init(slashToken: TokenSyntax, bindingList: BindingListSyntax, arrowToken: TokenSyntax, bodyExpr: ExprSyntax) {
    let raw = RawSyntax.node(.lambdaExpr, [
      slashToken.raw,
      bindingList.raw,
      arrowToken.raw,
      bodyExpr.raw,
    ], .present)
    let data = SyntaxData(raw: raw, indexInParent: 0, parent: nil)
    self.init(root: data, data: data)
  }
  public var slashToken: TokenSyntax {
    return child(at: Cursor.slashToken) as! TokenSyntax
  }
  public func withSlashToken(_ syntax: TokenSyntax) -> LambdaExprSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.slashToken)
    return LambdaExprSyntax(root: newRoot, data: newData)
  }

  public var bindingList: BindingListSyntax {
    return child(at: Cursor.bindingList) as! BindingListSyntax
  }
  public func withBindingList(_ syntax: BindingListSyntax) -> LambdaExprSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.bindingList)
    return LambdaExprSyntax(root: newRoot, data: newData)
  }

  public var arrowToken: TokenSyntax {
    return child(at: Cursor.arrowToken) as! TokenSyntax
  }
  public func withArrowToken(_ syntax: TokenSyntax) -> LambdaExprSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.arrowToken)
    return LambdaExprSyntax(root: newRoot, data: newData)
  }

  public var bodyExpr: ExprSyntax {
    return child(at: Cursor.bodyExpr) as! ExprSyntax
  }
  public func withBodyExpr(_ syntax: ExprSyntax) -> LambdaExprSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.bodyExpr)
    return LambdaExprSyntax(root: newRoot, data: newData)
  }

}

public struct QuantifiedExprSyntax: ExprSyntax, _SyntaxBase {
  let _root: SyntaxData
  unowned let _data: SyntaxData
  public enum Cursor: Int {
    case forallToken
    case bindingList
    case arrowToken
    case outputExpr
  }

  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
  }
  public init(forallToken: TokenSyntax, bindingList: TypedParameterListSyntax, arrowToken: TokenSyntax, outputExpr: ExprSyntax) {
    let raw = RawSyntax.node(.quantifiedExpr, [
      forallToken.raw,
      bindingList.raw,
      arrowToken.raw,
      outputExpr.raw,
    ], .present)
    let data = SyntaxData(raw: raw, indexInParent: 0, parent: nil)
    self.init(root: data, data: data)
  }
  public var forallToken: TokenSyntax {
    return child(at: Cursor.forallToken) as! TokenSyntax
  }
  public func withForallToken(_ syntax: TokenSyntax) -> QuantifiedExprSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.forallToken)
    return QuantifiedExprSyntax(root: newRoot, data: newData)
  }

  public var bindingList: TypedParameterListSyntax {
    return child(at: Cursor.bindingList) as! TypedParameterListSyntax
  }
  public func withBindingList(_ syntax: TypedParameterListSyntax) -> QuantifiedExprSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.bindingList)
    return QuantifiedExprSyntax(root: newRoot, data: newData)
  }

  public var arrowToken: TokenSyntax {
    return child(at: Cursor.arrowToken) as! TokenSyntax
  }
  public func withArrowToken(_ syntax: TokenSyntax) -> QuantifiedExprSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.arrowToken)
    return QuantifiedExprSyntax(root: newRoot, data: newData)
  }

  public var outputExpr: ExprSyntax {
    return child(at: Cursor.outputExpr) as! ExprSyntax
  }
  public func withOutputExpr(_ syntax: ExprSyntax) -> QuantifiedExprSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.outputExpr)
    return QuantifiedExprSyntax(root: newRoot, data: newData)
  }

}

public struct LetExprSyntax: ExprSyntax, _SyntaxBase {
  let _root: SyntaxData
  unowned let _data: SyntaxData
  public enum Cursor: Int {
    case letToken
    case leftBraceToken
    case declList
    case rightBraceToken
    case inToken
    case outputExpr
  }

  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
  }
  public init(letToken: TokenSyntax, leftBraceToken: TokenSyntax, declList: DeclListSyntax, rightBraceToken: TokenSyntax, inToken: TokenSyntax, outputExpr: ExprSyntax) {
    let raw = RawSyntax.node(.letExpr, [
      letToken.raw,
      leftBraceToken.raw,
      declList.raw,
      rightBraceToken.raw,
      inToken.raw,
      outputExpr.raw,
    ], .present)
    let data = SyntaxData(raw: raw, indexInParent: 0, parent: nil)
    self.init(root: data, data: data)
  }
  public var letToken: TokenSyntax {
    return child(at: Cursor.letToken) as! TokenSyntax
  }
  public func withLetToken(_ syntax: TokenSyntax) -> LetExprSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.letToken)
    return LetExprSyntax(root: newRoot, data: newData)
  }

  public var leftBraceToken: TokenSyntax {
    return child(at: Cursor.leftBraceToken) as! TokenSyntax
  }
  public func withLeftBraceToken(_ syntax: TokenSyntax) -> LetExprSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.leftBraceToken)
    return LetExprSyntax(root: newRoot, data: newData)
  }

  public var declList: DeclListSyntax {
    return child(at: Cursor.declList) as! DeclListSyntax
  }
  public func withDeclList(_ syntax: DeclListSyntax) -> LetExprSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.declList)
    return LetExprSyntax(root: newRoot, data: newData)
  }

  public var rightBraceToken: TokenSyntax {
    return child(at: Cursor.rightBraceToken) as! TokenSyntax
  }
  public func withRightBraceToken(_ syntax: TokenSyntax) -> LetExprSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.rightBraceToken)
    return LetExprSyntax(root: newRoot, data: newData)
  }

  public var inToken: TokenSyntax {
    return child(at: Cursor.inToken) as! TokenSyntax
  }
  public func withInToken(_ syntax: TokenSyntax) -> LetExprSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.inToken)
    return LetExprSyntax(root: newRoot, data: newData)
  }

  public var outputExpr: ExprSyntax {
    return child(at: Cursor.outputExpr) as! ExprSyntax
  }
  public func withOutputExpr(_ syntax: ExprSyntax) -> LetExprSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.outputExpr)
    return LetExprSyntax(root: newRoot, data: newData)
  }

}

public struct ApplicationExprSyntax: ExprSyntax, _SyntaxBase {
  let _root: SyntaxData
  unowned let _data: SyntaxData
  public enum Cursor: Int {
    case exprs
  }

  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
  }
  public init(exprs: BasicExprListSyntax) {
    let raw = RawSyntax.node(.applicationExpr, [
      exprs.raw,
    ], .present)
    let data = SyntaxData(raw: raw, indexInParent: 0, parent: nil)
    self.init(root: data, data: data)
  }
  public var exprs: BasicExprListSyntax {
    return child(at: Cursor.exprs) as! BasicExprListSyntax
  }
  public func withExprs(_ syntax: BasicExprListSyntax) -> ApplicationExprSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.exprs)
    return ApplicationExprSyntax(root: newRoot, data: newData)
  }

}

public struct BindingListSyntax: _SyntaxBase {
  let _root: SyntaxData
  unowned let _data: SyntaxData

  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
  }

  public init(elements: [BindingSyntax]) {
    let list = elements.map { $0.raw }
    let sd = SyntaxData(raw: .node(.bindingList, list, .present))
    self._root = sd
    self._data = sd
  }


  /// Creates a new BindingListSyntax by replacing the underlying layout with
  /// a different set of raw syntax nodes.
  ///
  /// - Parameter layout: The new list of raw syntax nodes underlying this
  ///                     collection.
  /// - Returns: A new SyntaxCollection with the new layout underlying it.
  internal func replacingLayout(
    _ layout: [RawSyntax]) -> BindingListSyntax {
    let newRaw = data.raw.replacingLayout(layout)
    let (newRoot, newData) = data.replacingSelf(newRaw)
    return BindingListSyntax(root: newRoot, data: newData)
  }

  /// Creates a new BindingListSyntax by appending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to append.
  /// - Returns: A new SyntaxCollection with that element appended to the end.
  public func appending(
    _ syntax: BindingSyntax) -> BindingListSyntax {
    var newLayout = data.raw.layout
    newLayout.append(syntax.raw)
    return replacingLayout(newLayout)
  }

  /// Creates a new BindingListSyntax by prepending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to prepend.
  /// - Returns: A new SyntaxCollection with that element prepended to the
  ///            beginning.
  public func prepending(
    _ syntax: BindingSyntax) -> BindingListSyntax {
    return inserting(syntax, at: 0)
  }

  /// Creates a new BindingListSyntax by inserting the provided syntax element
  /// at the provided index in the children.
  ///
  /// - Parameters:
  ///   - syntax: The element to insert.
  ///   - index: The index at which to insert the element in the collection.
  ///
  /// - Returns: A new BindingListSyntax with that element appended to the end.
  public func inserting(_ syntax: BindingSyntax,
                        at index: Int) -> BindingListSyntax {
    var newLayout = data.raw.layout
    /// Make sure the index is a valid insertion index (0 to 1 past the end)
    precondition((newLayout.startIndex...newLayout.endIndex).contains(index),
                 "inserting node at invalid index \(index)")
    newLayout.insert(syntax.raw, at: index)
    return replacingLayout(newLayout)
  }

  /// Creates a new BindingListSyntax by removing the syntax element at the
  /// provided index.
  ///
  /// - Parameter index: The index of the element to remove from the collection.
  /// - Returns: A new BindingListSyntax with the element at the provided index
  ///            removed.
  public func removing(childAt index: Int) -> BindingListSyntax {
    var newLayout = data.raw.layout
    newLayout.remove(at: index)
    return replacingLayout(newLayout)
  }

  /// Creates a new BindingListSyntax by removing the first element.
  ///
  /// - Returns: A new BindingListSyntax with the first element removed.
  public func removingFirst() -> BindingListSyntax {
    var newLayout = data.raw.layout
    newLayout.removeFirst()
    return replacingLayout(newLayout)
  }

  /// Creates a new BindingListSyntax by removing the last element.
  ///
  /// - Returns: A new BindingListSyntax with the last element removed.
  public func removingLast() -> BindingListSyntax {
    var newLayout = data.raw.layout
    newLayout.removeLast()
    return replacingLayout(newLayout)
  }

  /// Returns an iterator over the elements of this syntax collection.
  public func makeIterator() -> BindingListSyntaxIterator {
    return BindingListSyntaxIterator(collection: self)
  }
}

/// Conformance for BindingListSyntax to the Collection protocol.
extension BindingListSyntax: Collection {
  public var startIndex: Int {
    return data.childCaches.startIndex
  }

  public var endIndex: Int {
    return data.childCaches.endIndex
  }

  public func index(after i: Int) -> Int {
    return data.childCaches.index(after: i)
  }

  public subscript(_ index: Int) -> BindingSyntax {
    // swiftlint:disable force_cast
    return child(at: index)! as! BindingSyntax
  }
}

/// A type that iterates over a syntax collection using its indices.
public struct BindingListSyntaxIterator: IteratorProtocol {
  private let collection: BindingListSyntax
  private var index: BindingListSyntax.Index

  fileprivate init(collection: BindingListSyntax) {
    self.collection = collection
    self.index = collection.startIndex
  }

  public mutating func next() -> BindingSyntax? {
    guard
      !(self.collection.isEmpty || self.index == self.collection.endIndex)
    else {
      return nil
    }

    let result = collection[index]
    collection.formIndex(after: &index)
    return result
  }
}
public struct NamedBindingSyntax: BindingSyntax, _SyntaxBase {
  let _root: SyntaxData
  unowned let _data: SyntaxData
  public enum Cursor: Int {
    case name
  }

  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
  }
  public init(name: QualifiedNameSyntax) {
    let raw = RawSyntax.node(.namedBinding, [
      name.raw,
    ], .present)
    let data = SyntaxData(raw: raw, indexInParent: 0, parent: nil)
    self.init(root: data, data: data)
  }
  public var name: QualifiedNameSyntax {
    return child(at: Cursor.name) as! QualifiedNameSyntax
  }
  public func withName(_ syntax: QualifiedNameSyntax) -> NamedBindingSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.name)
    return NamedBindingSyntax(root: newRoot, data: newData)
  }

}

public struct TypedBindingSyntax: BindingSyntax, _SyntaxBase {
  let _root: SyntaxData
  unowned let _data: SyntaxData
  public enum Cursor: Int {
    case parameter
  }

  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
  }
  public init(parameter: TypedParameterSyntax) {
    let raw = RawSyntax.node(.typedBinding, [
      parameter.raw,
    ], .present)
    let data = SyntaxData(raw: raw, indexInParent: 0, parent: nil)
    self.init(root: data, data: data)
  }
  public var parameter: TypedParameterSyntax {
    return child(at: Cursor.parameter) as! TypedParameterSyntax
  }
  public func withParameter(_ syntax: TypedParameterSyntax) -> TypedBindingSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.parameter)
    return TypedBindingSyntax(root: newRoot, data: newData)
  }

}

public struct BasicExprListSyntax: _SyntaxBase {
  let _root: SyntaxData
  unowned let _data: SyntaxData

  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
  }

  public init(elements: [BasicExprSyntax]) {
    let list = elements.map { $0.raw }
    let sd = SyntaxData(raw: .node(.basicExprList, list, .present))
    self._root = sd
    self._data = sd
  }


  /// Creates a new BasicExprListSyntax by replacing the underlying layout with
  /// a different set of raw syntax nodes.
  ///
  /// - Parameter layout: The new list of raw syntax nodes underlying this
  ///                     collection.
  /// - Returns: A new SyntaxCollection with the new layout underlying it.
  internal func replacingLayout(
    _ layout: [RawSyntax]) -> BasicExprListSyntax {
    let newRaw = data.raw.replacingLayout(layout)
    let (newRoot, newData) = data.replacingSelf(newRaw)
    return BasicExprListSyntax(root: newRoot, data: newData)
  }

  /// Creates a new BasicExprListSyntax by appending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to append.
  /// - Returns: A new SyntaxCollection with that element appended to the end.
  public func appending(
    _ syntax: BasicExprSyntax) -> BasicExprListSyntax {
    var newLayout = data.raw.layout
    newLayout.append(syntax.raw)
    return replacingLayout(newLayout)
  }

  /// Creates a new BasicExprListSyntax by prepending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to prepend.
  /// - Returns: A new SyntaxCollection with that element prepended to the
  ///            beginning.
  public func prepending(
    _ syntax: BasicExprSyntax) -> BasicExprListSyntax {
    return inserting(syntax, at: 0)
  }

  /// Creates a new BasicExprListSyntax by inserting the provided syntax element
  /// at the provided index in the children.
  ///
  /// - Parameters:
  ///   - syntax: The element to insert.
  ///   - index: The index at which to insert the element in the collection.
  ///
  /// - Returns: A new BasicExprListSyntax with that element appended to the end.
  public func inserting(_ syntax: BasicExprSyntax,
                        at index: Int) -> BasicExprListSyntax {
    var newLayout = data.raw.layout
    /// Make sure the index is a valid insertion index (0 to 1 past the end)
    precondition((newLayout.startIndex...newLayout.endIndex).contains(index),
                 "inserting node at invalid index \(index)")
    newLayout.insert(syntax.raw, at: index)
    return replacingLayout(newLayout)
  }

  /// Creates a new BasicExprListSyntax by removing the syntax element at the
  /// provided index.
  ///
  /// - Parameter index: The index of the element to remove from the collection.
  /// - Returns: A new BasicExprListSyntax with the element at the provided index
  ///            removed.
  public func removing(childAt index: Int) -> BasicExprListSyntax {
    var newLayout = data.raw.layout
    newLayout.remove(at: index)
    return replacingLayout(newLayout)
  }

  /// Creates a new BasicExprListSyntax by removing the first element.
  ///
  /// - Returns: A new BasicExprListSyntax with the first element removed.
  public func removingFirst() -> BasicExprListSyntax {
    var newLayout = data.raw.layout
    newLayout.removeFirst()
    return replacingLayout(newLayout)
  }

  /// Creates a new BasicExprListSyntax by removing the last element.
  ///
  /// - Returns: A new BasicExprListSyntax with the last element removed.
  public func removingLast() -> BasicExprListSyntax {
    var newLayout = data.raw.layout
    newLayout.removeLast()
    return replacingLayout(newLayout)
  }

  /// Returns an iterator over the elements of this syntax collection.
  public func makeIterator() -> BasicExprListSyntaxIterator {
    return BasicExprListSyntaxIterator(collection: self)
  }
}

/// Conformance for BasicExprListSyntax to the Collection protocol.
extension BasicExprListSyntax: Collection {
  public var startIndex: Int {
    return data.childCaches.startIndex
  }

  public var endIndex: Int {
    return data.childCaches.endIndex
  }

  public func index(after i: Int) -> Int {
    return data.childCaches.index(after: i)
  }

  public subscript(_ index: Int) -> BasicExprSyntax {
    // swiftlint:disable force_cast
    return child(at: index)! as! BasicExprSyntax
  }
}

/// A type that iterates over a syntax collection using its indices.
public struct BasicExprListSyntaxIterator: IteratorProtocol {
  private let collection: BasicExprListSyntax
  private var index: BasicExprListSyntax.Index

  fileprivate init(collection: BasicExprListSyntax) {
    self.collection = collection
    self.index = collection.startIndex
  }

  public mutating func next() -> BasicExprSyntax? {
    guard
      !(self.collection.isEmpty || self.index == self.collection.endIndex)
    else {
      return nil
    }

    let result = collection[index]
    collection.formIndex(after: &index)
    return result
  }
}
public struct NamedBasicExprSyntax: BasicExprSyntax, _SyntaxBase {
  let _root: SyntaxData
  unowned let _data: SyntaxData
  public enum Cursor: Int {
    case name
  }

  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
  }
  public init(name: QualifiedNameSyntax) {
    let raw = RawSyntax.node(.namedBasicExpr, [
      name.raw,
    ], .present)
    let data = SyntaxData(raw: raw, indexInParent: 0, parent: nil)
    self.init(root: data, data: data)
  }
  public var name: QualifiedNameSyntax {
    return child(at: Cursor.name) as! QualifiedNameSyntax
  }
  public func withName(_ syntax: QualifiedNameSyntax) -> NamedBasicExprSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.name)
    return NamedBasicExprSyntax(root: newRoot, data: newData)
  }

}

public struct UnderscoreExprSyntax: BasicExprSyntax, _SyntaxBase {
  let _root: SyntaxData
  unowned let _data: SyntaxData
  public enum Cursor: Int {
    case underscoreToken
  }

  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
  }
  public init(underscoreToken: TokenSyntax) {
    let raw = RawSyntax.node(.underscoreExpr, [
      underscoreToken.raw,
    ], .present)
    let data = SyntaxData(raw: raw, indexInParent: 0, parent: nil)
    self.init(root: data, data: data)
  }
  public var underscoreToken: TokenSyntax {
    return child(at: Cursor.underscoreToken) as! TokenSyntax
  }
  public func withUnderscoreToken(_ syntax: TokenSyntax) -> UnderscoreExprSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.underscoreToken)
    return UnderscoreExprSyntax(root: newRoot, data: newData)
  }

}

public struct TypeBasicExprSyntax: BasicExprSyntax, _SyntaxBase {
  let _root: SyntaxData
  unowned let _data: SyntaxData
  public enum Cursor: Int {
    case typeToken
  }

  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
  }
  public init(typeToken: TokenSyntax) {
    let raw = RawSyntax.node(.typeBasicExpr, [
      typeToken.raw,
    ], .present)
    let data = SyntaxData(raw: raw, indexInParent: 0, parent: nil)
    self.init(root: data, data: data)
  }
  public var typeToken: TokenSyntax {
    return child(at: Cursor.typeToken) as! TokenSyntax
  }
  public func withTypeToken(_ syntax: TokenSyntax) -> TypeBasicExprSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.typeToken)
    return TypeBasicExprSyntax(root: newRoot, data: newData)
  }

}

public struct ParenthesizedExprSyntax: BasicExprSyntax, _SyntaxBase {
  let _root: SyntaxData
  unowned let _data: SyntaxData
  public enum Cursor: Int {
    case leftParenToken
    case expr
    case rightParenToken
  }

  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
  }
  public init(leftParenToken: TokenSyntax, expr: ExprSyntax, rightParenToken: TokenSyntax) {
    let raw = RawSyntax.node(.parenthesizedExpr, [
      leftParenToken.raw,
      expr.raw,
      rightParenToken.raw,
    ], .present)
    let data = SyntaxData(raw: raw, indexInParent: 0, parent: nil)
    self.init(root: data, data: data)
  }
  public var leftParenToken: TokenSyntax {
    return child(at: Cursor.leftParenToken) as! TokenSyntax
  }
  public func withLeftParenToken(_ syntax: TokenSyntax) -> ParenthesizedExprSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.leftParenToken)
    return ParenthesizedExprSyntax(root: newRoot, data: newData)
  }

  public var expr: ExprSyntax {
    return child(at: Cursor.expr) as! ExprSyntax
  }
  public func withExpr(_ syntax: ExprSyntax) -> ParenthesizedExprSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.expr)
    return ParenthesizedExprSyntax(root: newRoot, data: newData)
  }

  public var rightParenToken: TokenSyntax {
    return child(at: Cursor.rightParenToken) as! TokenSyntax
  }
  public func withRightParenToken(_ syntax: TokenSyntax) -> ParenthesizedExprSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.rightParenToken)
    return ParenthesizedExprSyntax(root: newRoot, data: newData)
  }

}

public struct TypedParameterGroupExprSyntax: BasicExprSyntax, _SyntaxBase {
  let _root: SyntaxData
  unowned let _data: SyntaxData
  public enum Cursor: Int {
    case parameters
  }

  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
  }
  public init(parameters: TypedParameterListSyntax) {
    let raw = RawSyntax.node(.typedParameterGroupExpr, [
      parameters.raw,
    ], .present)
    let data = SyntaxData(raw: raw, indexInParent: 0, parent: nil)
    self.init(root: data, data: data)
  }
  public var parameters: TypedParameterListSyntax {
    return child(at: Cursor.parameters) as! TypedParameterListSyntax
  }
  public func withParameters(_ syntax: TypedParameterListSyntax) -> TypedParameterGroupExprSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.parameters)
    return TypedParameterGroupExprSyntax(root: newRoot, data: newData)
  }

}

public struct RecordExprSyntax: BasicExprSyntax, _SyntaxBase {
  let _root: SyntaxData
  unowned let _data: SyntaxData
  public enum Cursor: Int {
    case recordToken
    case parameterExpr
    case leftBraceToken
    case fieldAssignments
    case rightBraceToken
  }

  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
  }
  public init(recordToken: TokenSyntax, parameterExpr: BasicExprSyntax?, leftBraceToken: TokenSyntax, fieldAssignments: RecordFieldAssignmentListSyntax, rightBraceToken: TokenSyntax) {
    let raw = RawSyntax.node(.recordExpr, [
      recordToken.raw,
      parameterExpr?.raw ?? RawSyntax.missing(.basicExpr),
      leftBraceToken.raw,
      fieldAssignments.raw,
      rightBraceToken.raw,
    ], .present)
    let data = SyntaxData(raw: raw, indexInParent: 0, parent: nil)
    self.init(root: data, data: data)
  }
  public var recordToken: TokenSyntax {
    return child(at: Cursor.recordToken) as! TokenSyntax
  }
  public func withRecordToken(_ syntax: TokenSyntax) -> RecordExprSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.recordToken)
    return RecordExprSyntax(root: newRoot, data: newData)
  }

  public var parameterExpr: BasicExprSyntax? {
    return child(at: Cursor.parameterExpr) as? BasicExprSyntax
  }
  public func withParameterExpr(_ syntax: BasicExprSyntax) -> RecordExprSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.parameterExpr)
    return RecordExprSyntax(root: newRoot, data: newData)
  }

  public var leftBraceToken: TokenSyntax {
    return child(at: Cursor.leftBraceToken) as! TokenSyntax
  }
  public func withLeftBraceToken(_ syntax: TokenSyntax) -> RecordExprSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.leftBraceToken)
    return RecordExprSyntax(root: newRoot, data: newData)
  }

  public var fieldAssignments: RecordFieldAssignmentListSyntax {
    return child(at: Cursor.fieldAssignments) as! RecordFieldAssignmentListSyntax
  }
  public func withFieldAssignments(_ syntax: RecordFieldAssignmentListSyntax) -> RecordExprSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.fieldAssignments)
    return RecordExprSyntax(root: newRoot, data: newData)
  }

  public var rightBraceToken: TokenSyntax {
    return child(at: Cursor.rightBraceToken) as! TokenSyntax
  }
  public func withRightBraceToken(_ syntax: TokenSyntax) -> RecordExprSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.rightBraceToken)
    return RecordExprSyntax(root: newRoot, data: newData)
  }

}

public struct FunctionClauseListSyntax: _SyntaxBase {
  let _root: SyntaxData
  unowned let _data: SyntaxData

  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
  }

  public init(elements: [FunctionClauseDeclSyntax]) {
    let list = elements.map { $0.raw }
    let sd = SyntaxData(raw: .node(.functionClauseList, list, .present))
    self._root = sd
    self._data = sd
  }


  /// Creates a new FunctionClauseListSyntax by replacing the underlying layout with
  /// a different set of raw syntax nodes.
  ///
  /// - Parameter layout: The new list of raw syntax nodes underlying this
  ///                     collection.
  /// - Returns: A new SyntaxCollection with the new layout underlying it.
  internal func replacingLayout(
    _ layout: [RawSyntax]) -> FunctionClauseListSyntax {
    let newRaw = data.raw.replacingLayout(layout)
    let (newRoot, newData) = data.replacingSelf(newRaw)
    return FunctionClauseListSyntax(root: newRoot, data: newData)
  }

  /// Creates a new FunctionClauseListSyntax by appending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to append.
  /// - Returns: A new SyntaxCollection with that element appended to the end.
  public func appending(
    _ syntax: FunctionClauseDeclSyntax) -> FunctionClauseListSyntax {
    var newLayout = data.raw.layout
    newLayout.append(syntax.raw)
    return replacingLayout(newLayout)
  }

  /// Creates a new FunctionClauseListSyntax by prepending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to prepend.
  /// - Returns: A new SyntaxCollection with that element prepended to the
  ///            beginning.
  public func prepending(
    _ syntax: FunctionClauseDeclSyntax) -> FunctionClauseListSyntax {
    return inserting(syntax, at: 0)
  }

  /// Creates a new FunctionClauseListSyntax by inserting the provided syntax element
  /// at the provided index in the children.
  ///
  /// - Parameters:
  ///   - syntax: The element to insert.
  ///   - index: The index at which to insert the element in the collection.
  ///
  /// - Returns: A new FunctionClauseListSyntax with that element appended to the end.
  public func inserting(_ syntax: FunctionClauseDeclSyntax,
                        at index: Int) -> FunctionClauseListSyntax {
    var newLayout = data.raw.layout
    /// Make sure the index is a valid insertion index (0 to 1 past the end)
    precondition((newLayout.startIndex...newLayout.endIndex).contains(index),
                 "inserting node at invalid index \(index)")
    newLayout.insert(syntax.raw, at: index)
    return replacingLayout(newLayout)
  }

  /// Creates a new FunctionClauseListSyntax by removing the syntax element at the
  /// provided index.
  ///
  /// - Parameter index: The index of the element to remove from the collection.
  /// - Returns: A new FunctionClauseListSyntax with the element at the provided index
  ///            removed.
  public func removing(childAt index: Int) -> FunctionClauseListSyntax {
    var newLayout = data.raw.layout
    newLayout.remove(at: index)
    return replacingLayout(newLayout)
  }

  /// Creates a new FunctionClauseListSyntax by removing the first element.
  ///
  /// - Returns: A new FunctionClauseListSyntax with the first element removed.
  public func removingFirst() -> FunctionClauseListSyntax {
    var newLayout = data.raw.layout
    newLayout.removeFirst()
    return replacingLayout(newLayout)
  }

  /// Creates a new FunctionClauseListSyntax by removing the last element.
  ///
  /// - Returns: A new FunctionClauseListSyntax with the last element removed.
  public func removingLast() -> FunctionClauseListSyntax {
    var newLayout = data.raw.layout
    newLayout.removeLast()
    return replacingLayout(newLayout)
  }

  /// Returns an iterator over the elements of this syntax collection.
  public func makeIterator() -> FunctionClauseListSyntaxIterator {
    return FunctionClauseListSyntaxIterator(collection: self)
  }
}

/// Conformance for FunctionClauseListSyntax to the Collection protocol.
extension FunctionClauseListSyntax: Collection {
  public var startIndex: Int {
    return data.childCaches.startIndex
  }

  public var endIndex: Int {
    return data.childCaches.endIndex
  }

  public func index(after i: Int) -> Int {
    return data.childCaches.index(after: i)
  }

  public subscript(_ index: Int) -> FunctionClauseDeclSyntax {
    // swiftlint:disable force_cast
    return child(at: index)! as! FunctionClauseDeclSyntax
  }
}

/// A type that iterates over a syntax collection using its indices.
public struct FunctionClauseListSyntaxIterator: IteratorProtocol {
  private let collection: FunctionClauseListSyntax
  private var index: FunctionClauseListSyntax.Index

  fileprivate init(collection: FunctionClauseListSyntax) {
    self.collection = collection
    self.index = collection.startIndex
  }

  public mutating func next() -> FunctionClauseDeclSyntax? {
    guard
      !(self.collection.isEmpty || self.index == self.collection.endIndex)
    else {
      return nil
    }

    let result = collection[index]
    collection.formIndex(after: &index)
    return result
  }
}
public struct ReparsedFunctionDeclSyntax: DeclSyntax, _SyntaxBase {
  let _root: SyntaxData
  unowned let _data: SyntaxData
  public enum Cursor: Int {
    case ascription
    case trailingSemicolon
    case clauseList
  }

  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
  }
  public init(ascription: AscriptionSyntax, trailingSemicolon: TokenSyntax, clauseList: FunctionClauseListSyntax) {
    let raw = RawSyntax.node(.reparsedFunctionDecl, [
      ascription.raw,
      trailingSemicolon.raw,
      clauseList.raw,
    ], .present)
    let data = SyntaxData(raw: raw, indexInParent: 0, parent: nil)
    self.init(root: data, data: data)
  }
  public var ascription: AscriptionSyntax {
    return child(at: Cursor.ascription) as! AscriptionSyntax
  }
  public func withAscription(_ syntax: AscriptionSyntax) -> ReparsedFunctionDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.ascription)
    return ReparsedFunctionDeclSyntax(root: newRoot, data: newData)
  }

  public var trailingSemicolon: TokenSyntax {
    return child(at: Cursor.trailingSemicolon) as! TokenSyntax
  }
  public func withTrailingSemicolon(_ syntax: TokenSyntax) -> ReparsedFunctionDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.trailingSemicolon)
    return ReparsedFunctionDeclSyntax(root: newRoot, data: newData)
  }

  public var clauseList: FunctionClauseListSyntax {
    return child(at: Cursor.clauseList) as! FunctionClauseListSyntax
  }
  public func withClauseList(_ syntax: FunctionClauseListSyntax) -> ReparsedFunctionDeclSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.clauseList)
    return ReparsedFunctionDeclSyntax(root: newRoot, data: newData)
  }

}

public struct ReparsedApplicationExprSyntax: BasicExprSyntax, _SyntaxBase {
  let _root: SyntaxData
  unowned let _data: SyntaxData
  public enum Cursor: Int {
    case head
    case exprs
  }

  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
  }
  public init(head: NamedBasicExprSyntax, exprs: BasicExprListSyntax) {
    let raw = RawSyntax.node(.reparsedApplicationExpr, [
      head.raw,
      exprs.raw,
    ], .present)
    let data = SyntaxData(raw: raw, indexInParent: 0, parent: nil)
    self.init(root: data, data: data)
  }
  public var head: NamedBasicExprSyntax {
    return child(at: Cursor.head) as! NamedBasicExprSyntax
  }
  public func withHead(_ syntax: NamedBasicExprSyntax) -> ReparsedApplicationExprSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.head)
    return ReparsedApplicationExprSyntax(root: newRoot, data: newData)
  }

  public var exprs: BasicExprListSyntax {
    return child(at: Cursor.exprs) as! BasicExprListSyntax
  }
  public func withExprs(_ syntax: BasicExprListSyntax) -> ReparsedApplicationExprSyntax {
    let (newRoot, newData) = data.replacingChild(syntax.raw, at: Cursor.exprs)
    return ReparsedApplicationExprSyntax(root: newRoot, data: newData)
  }

}

